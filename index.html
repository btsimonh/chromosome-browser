<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Yulvil/btsimonh Chromosome Browser</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <style>
div.tooltip {
    position: absolute;
    text-align: left;
    padding: 10px;
    font: 12px sans-serif;
    background: lightsteelblue;
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
    z-index: 2000;
}

textarea {
    width: 100%;
    // height: 55px;
}

.drop_zone {
	border: 2px dashed #000;
	width:  250px;
	height: 100px;
	float: left;
	text-align: center;
	margin: 0px 20px 0px 0px;
}

input[type=number]{
    width: 70px;
	font-size: 16px;
	text-align: center;
	font-weight: bold;
}

#csvdiv0 {
	display: none;
}

body {
	margin: 0;
}

#topdiv {
	position: static;
	padding: 10px;
}

header {
	margin: 0;
	padding: 0;
	overflow: hidden;
}

nav ul {
	background-color: #333;
	list-style-type: none;
	margin: 0;
	padding: 0;
	overflow: hidden;
}

nav li {
	float: left;
}

nav li a {
	display: block;
	color: white;
	text-align: center;
	padding: 14px 16px;
	text-decoration: none;
}

/* Change the link color to #111 (black) on hover */
nav li a:hover {
	background-color: #111;
}

nav .active {
	background-color: #4CAF50;
}

nav {
	margin: 0;
	position: sticky;
	top: 0;
	right: 0;
	left: 0;
	z-index: 1000;
}

.inputs {
	display: none;
	padding: 10px;
}

.submenu {
	background-color: #555;
	color: white;
}

.chrbrowser {
  background:white;
	padding: 5px;
}
.chrbox {
}

div a:link, div a:visited {
	color: yellow;
	font-weight: bold;
}

/* context menu */

.context-menu {
  display: none;
  position: absolute;
  z-index: 10;
  padding: 12px 0;
  width: auto;
  background-color: #fff;
  border: solid 1px #dfdfdf;
  box-shadow: 1px 1px 2px #cfcfcf;
}

.context-menu--active {
  display: block;
}

.context-menu__items {
  list-style: none;
  margin: 0;
  padding: 0;
}

.context-menu__item {
  display: block;
  margin-bottom: 4px;
}

.context-menu__item:last-child {
  margin-bottom: 0;
}

.context-menu__link {
  display: block;
  padding: 4px 12px;
  color: #0066aa;
  text-decoration: none;
}

.context-menu__link:hover {
  color: #fff;
  background-color: #0066aa;
}

    </style>
  </head>
  <body>

<header>
</header>

<form id="myform" onsubmit="return false;">

<nav>
<ul>
  <li><a href="#" onclick="showdiv('none');">Yulvil Chromosome Browser</a></li>
  <li><a href="#Data" onclick="showdiv('data');">Data</a></li>
  <li><a href="#Filters" onclick="showdiv('filters');">Filters</a></li>
  <li><a href="#Display" onclick="showdiv('display');">Display</a></li>
  <li style="float: right"><a href="#" onclick="showdiv('about');">About</a></li>
</ul>

<div class="submenu">
<div class="inputs" id="none">
<a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a><br/>
</div>
<div class="inputs" id="data">
<a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a><br/>
<div style="width: 100%; overflow: hidden;">

<div class="drop_zone" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);">
  <p>&#128193; Drag one or more files here</p>
</div>

<div class="drop_zone" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);">
<p>
  <label class="custom-file-upload">
    <input type="file" multiple="multiple" accept=".csv, .txt" onchange="onFileSelect(this);" style="display: none;"/>
    &#128193; Select files from your computer
  </label>
</p>
</div>

<div class="drop_zone" ondrop="dropHandler2(event);" ondragover="dragOverHandler(event);">
  <p>&#128193; Select myHeritage matches list file from your computer</p>
</div>


<div style="float: left;">
  <p>or
  <input type="button" name="addCsv" id="addCsv" value="Add CSV data" onclick="addCsvInput();" />
  </p>
</div>
</div>

<div id="csvdatadiv">
  <div id="csvdiv0">
    <br/><br/>
    <label for="csvdata0">CSV Data</label>
    <br/>
    <textarea name="csvdata0" id="csvdata0" class="csvdata" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" onChange="loadData();updateAll();"></textarea>
  </div>
</div>

</div>
<div class="inputs" id="filters">
<a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a><br/>
<label for="minCm">Centimorgan size</label>
from <input id="minCm" type="number" value="10" onChange="updateCm();" onInput="updateCm();">
to <input id="maxCm" type="number" value="" onChange="updateCm();" onInput="updateCm();">

<br/><br/>
<label for="includekits">Only show these kits (one per line)</label>
<br/>
<textarea name="includekits" id="includekits" onChange="updateAll();"></textarea>

<br/><br/>
<label for="excludekits">Exclude these kits (one per line)</label>
<br/>
<textarea name="excludekits" id="excludekits" onChange="updateAll();"></textarea>
</div>
<div class="inputs" id="display">
<a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a><br/>
<label for="chrview">Chromosome</label>
<select id="chrview" onChange="updateAll()">
  <option value="0">All</option>
  <option value="1">1</option>
  <option value="2">2</option>
  <option value="3">3</option>
  <option value="4">4</option>
  <option value="5">5</option>
  <option value="6">6</option>
  <option value="7">7</option>
  <option value="8">8</option>
  <option value="9">9</option>
  <option value="10">10</option>
  <option value="11">11</option>
  <option value="12">12</option>
  <option value="13">13</option>
  <option value="14">14</option>
  <option value="15">15</option>
  <option value="16">16</option>
  <option value="17">17</option>
  <option value="18">18</option>
  <option value="19">19</option>
  <option value="20">20</option>
  <option value="21">21</option>
  <option value="22">22</option>
  <option value="23">X</option>
</select>

<br/><br/>
<label for="chrsize">Chromosome Size</label>
<select id="chrsize" onchange="updatePosn();">
  <option value="screenwidth" selected="selected">screen width</option>
  <option value="proportional">proportional</option>
</select>

<br/><br/>
<label for="viewtype">View Type</label>
<select id="viewtype" onchange="updateViewType();">
  <option value="compact" selected="selected">Compact</option>
  <option value="compactreverse">Compact (reverse)</option>
  <option value="segment">By Segment</option>
  <option value="segmentreverse">By Segment (reverse)</option>
<!--
  <option value="kitsize">By Kit Size</option>
-->
</select>
<br/><br/>
<label for="segmentHeight">Segment Height</label>
<input id="segmentHeight" type="number" value="20" onChange="updatePosn();">

<br/><br/>
<label for="fromkit">Active Kit</label>
<select id="fromkit" onchange="updateAll();">
</select>

<br/><br/>
<label for="hideuncoloured">Show Segments</label>
<select id="hideuncoloured" onchange="updateHidden();">
  <option value="all" selected="selected">All</option>
  <option value="coloured">Solid Colour</option>
</select>

</div>
<div class="inputs" id="about">
Copyright (c) 2018 yulvil, 2022 btsimonh <a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a> and <a href="https://github.com/btsimonh/chromosome-browser" target="_blank">Source Code</a>
<div>Page views: <span id="visits">...</span></div>
</div>
</div>
<div class="tooltip" id="tooltip" style="opacity=0;"></div>

</nav>
</form>

<div id="divchrbrowser" style="position:relative;">

</div>

  <nav id="context-menu" class="context-menu">
    <button onclick="menuClick(event, 0)"> Highlight all segments which intersect this kit</button><br/>
    <button onclick="menuClick(event, 1)"> unHighlight all segments which intersect this kit</button><br/>
    <button onclick="menuClick(event, 2)"> Download Interesting Matches</button><br/>
    <button onclick="menuClick(event, 3)"> View Tree</button><br/>
    <button onclick="menuClick(event, 4)"> Review Match</button><br/>
  </nav>

  
    <script>
"use strict;";

// basic page counter; no informaton is sent to this server.
if (!document.URL.startsWith('file:')){
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "https://api.countapi.xyz/hit/btsimonh.github.io-chromosome-browser/visits");
  xhr.responseType = "json";
  xhr.onload = function() {
      document.getElementById('visits').innerText = this.response.value;
  }
  xhr.send();
} else {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "https://api.countapi.xyz/get/btsimonh.github.io-chromosome-browser/visits");
  xhr.responseType = "json";
  xhr.onload = function() {
      document.getElementById('visits').innerText = this.response.value;
  }
  xhr.send();

}

var compareSegment = function (a, b) {
	if (a.start < b.start) {
		return -1;
	} else if (a.start > b.start) {
		return 1;
	}

	if (a.cm < b.cm) {
		return 1;
	} else if (a.cm > b.cm) {
		return -1;
	}

	return -a.id.localeCompare(b.id);
};

var compareSegmentReverse = function (a, b) {
	if (a.end > b.end) {
		return -1;
	} else if (a.end < b.end) {
		return 1;
	}

	if (a.cm < b.cm) {
		return 1;
	} else if (a.cm > b.cm) {
		return -1;
	}

	return -a.id.localeCompare(b.id);
};

function sortBySegment(data, fcmp) {
	var d = data.sort(fcmp);
	for (var i = 0; i < d.length; i++) {
		d[i].row = i;
	}

	return {
		"data": d,
		"numRows": data.length
	};
}

/**
 * Get's exact position of event.
 * 
 * @param {Object} e The event passed in
 * @return {Object} Returns the x and y position
 */
function getPosition(e) {
  var posx = 0;
  var posy = 0;

  if (!e) var e = window.event;
  
  //if (e.pageX || e.pageY) {
    posx = e.pageX;
    posy = e.pageY;
//  } else if (e.clientX || e.clientY) {
    posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
    posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
//  }

  return {
    x: posx,
    y: posy
  }
}

var contextMenuClassName = "context-menu";
var contextMenuItemClassName = "context-menu__item";
var contextMenuLinkClassName = "context-menu__link";
var contextMenuActive = "context-menu--active";
var menu = document.querySelector("#context-menu");
var menuItems = menu.querySelectorAll(".context-menu__item");
var menuState = 0;
var menuWidth;
var menuHeight;
var menuPosition;
var menuPositionX;
var menuPositionY;
var menuSegid;

function contextMenu(e) {
  console.log('Context', e);
  taskItemInContext = e.target;

  if ( taskItemInContext ) {
    e.preventDefault();
    menuSegid = taskItemInContext.id;
    toggleMenuOn();
    positionMenu(e);
  } else {
    taskItemInContext = null;
    toggleMenuOff();
  }
}

 /**
   * Turns the custom context menu on.
   */
  function toggleMenuOn() {
    if ( menuState !== 1 ) {
      menuState = 1;
      menu.classList.add( contextMenuActive );
    }
  }

  /**
   * Turns the custom context menu off.
   */
  function toggleMenuOff() {
    if ( menuState !== 0 ) {
      menuState = 0;
      menu.classList.remove( contextMenuActive );
    }
  }

  /**
   * Positions the menu properly.
   * 
   * @param {Object} e The event
   */
  function positionMenu(e) {
    clickCoords = getPosition(e);
    clickCoordsX = clickCoords.x;
    clickCoordsY = clickCoords.y;

    menuWidth = menu.offsetWidth + 4;
    menuHeight = menu.offsetHeight + 4;

    windowWidth = window.innerWidth;
    windowHeight = window.innerHeight;

//    if ( (windowWidth - clickCoordsX) < menuWidth ) {
//      menu.style.left = windowWidth - menuWidth + "px";
//    } else {
      menu.style.left = clickCoordsX + "px";
//    }

//    if ( (windowHeight - clickCoordsY) < menuHeight ) {
//      menu.style.top = windowHeight - menuHeight + "px";
//    } else {
      menu.style.top = clickCoordsY + "px";
//    }
  }

function menuClick(ev, item){
  toggleMenuOff();

  let segid = menuSegid;
  let kit = getKitFromSeg(segid);

  switch(item){
    case 0:
      highlightAllMatching(kit, true);
      setHighlight();
      break;
    case 1:
      highlightAllMatching(kit, false);
      setHighlight();
      break;
    case 2:
      getInterestingSegs(segid);
      break;
    case 3:{
      if (matchesMeta[kit]){
        let url = matchesMeta[kit]['View tree'];
        if (url){
          var a = document.createElement('a');
          a.href = url;
          a.target = '_Blank';
          a.click();
        }
      }
    } break;
    case 4:{
      if (matchesMeta[kit]){
        let url = matchesMeta[kit]['Review DNA Match page'];
        if (url){
          var a = document.createElement('a');
          a.href = url;
          a.target = '_Blank';
          a.click();
        }
      }
    } break;
    
  }
}

// unused and incorrect
function sortByKitSize(data) {
	var kits = {};
	var numRows = 0;

	for (var i = 0; i < data.length; i++) {
		if (data[i].kit in kits) {
			kits[data[i].kit].total += data[i].cm;
		} else {
			kits[data[i].kit] = {
				"total": data[i].cm
			};
		}
	}

	var compareFunc = function (a, b) {
		if (kits[a.kit].total < kits[b.kit].total) {
			return 1;
		} else if (kits[a.kit].total > kits[b.kit].total) {
			return -1;
		}
		return -a.kit.localeCompare(b.kit);
	}

	var d = data.sort(compareFunc)
		var currKit = d[0].kit;
	var currRow = 0;
	for (var i = 0; i < d.length; i++) {
		if (currKit !== d[i].kit) {
			currKit = d[i].kit;
			currRow++;
		}
		d[i].row = currRow;

		if (numRows < currRow + 1)
			numRows = currRow + 1;
	}

	return {
		"data": d,
		"numRows": numRows
	};
}

function compact(data, fcmp) {
	var numRows = 1;
	var d = data.sort(fcmp);

	function overlap(s1, s2) {
		if (s1.row == s2.row) {
			if ((s1.start <= s2.start && s2.start <= s1.end) ||
				(s1.start <= s2.end && s2.end <= s1.end)) {
				return true;
			}
		}
		return false;
	}

	function overlapPrevious(segments, until) {
		for (var i = 0; i < until; i++) {
			if (overlap(segments[i], segments[until])) {
				return true;
			}
		}

		return false;
	}

	for (var i = 0; i < d.length; i++) {
		var j = 0;
		d[i].row = j;
		while (j < i && overlapPrevious(d, i)) {
			j++;
			d[i].row = j;

			if (numRows < j + 1)
				numRows = j + 1;
		}
	}

	return {
		"data": d,
		"numRows": numRows
	};
}


// data = {
//   "kit1": [segments],
//   "kit2": [segments]
// }
var data = {};
var segids = {};

var filteredData = [];

var actions = [];

// kits = {
//   "AZ123": {"name": "John Doe", "email": "a@b.c", "color": "..."},
// }
var kits = {};

var cat20 = d3.scaleOrdinal(d3.schemeCategory20);

function getSide(d) {
	let v = d.side || d.Side || 0;
	switch (v) {
		case "Paternal":
		case "paternal":
			return 1;
		case "Maternal":
		case "maternal":
			return 2;
		default:
			return +v % 3;
	}
}



function csvParse(text) {
	let currKit = Math.random().toString(36);

  let segments = [];
  
  /*let segments = */
  
  d3.csvParse(text, function (d, i) {
		var e = {};
    
    // myHeritage data is like:
    // DNA Match ID,Name,Match name,Chromosome,Start Location,End Location,Start RSID,End RSID,Centimorgans,SNPs,color
    // ,,,,,,,,,,
    // D-9901AC20-79C0-438F-98CA-AB11FEFE1876-D-FF58D9C4-FCEC-44F0-9654-EE143A17F70C,Simon Hailes,Beverley Porter,1,9500795,20451281,rs9662295,rs7531682,22.8,6656,red

    if (d['DNA Match ID']){
      if (d['DNA Match ID'] === 'action'){
        let action = {
          kit: d['Name'],
          type: d['type'],
        };
        actions.push(action);
        return {};
      }
      // like "D-9901AC20-79C0-438F-98CA-AB11FEFE1876-D-FF58D9C4-FCEC-44F0-9654-EE143A17F70C"
      let matchID = d['DNA Match ID'].split('-');
      let kitFrom = [];
      for (let i = 0; i < 6; i++){
        kitFrom.push(matchID.shift());
      }
      e.kitFrom = kitFrom.join('-');
      e.kitTo = matchID.join('-');
    } else {
      e.kitFrom = d.kit1 || d.name || d.NAME || d.Name || currKit;
      e.kitTo = d.kit2 || d.matchname || d.Match || d["MATCHNAME"] || d["Match name"] || d["Match Name"] || d["Display Name"] || "";
    }

		e.chr = (d.chr || d.Chr || d["CHROMOSOME"] || d["Chromosome"] || d["Chromosome Number"] || "0");
		e.chr = e.chr.trim() === "X" || e.chr.trim() === "x" ? 23 : + ("" + e.chr.trim()).replace(/chr/, "");
		if (e.chr < 1 || e.chr > 23) return;
    e.chr = +e.chr;

		e.start =  + (d.start || d.Start || d["START LOCATION"] || d["Start Location"] || d["Chromosome Start Point"] || "0").replace(/,/g, "");
		e.end =  + (d.end || d.End || d["END LOCATION"] || d["End Location"] || d["Chromosome End Point"] || "0").replace(/,/g, "");
    
    e.startRSID = d['Start RSID'];
    e.endRSID = d['End RSID'];
    
		e.cm =  + (d.cm || d.cM || d["CENTIMORGANS"] || d["Centimorgans"] || d["Genetic Distance"] || "0").replace(/,/g, "");
		e.side = getSide(d);
    
//    e.highlight = (e.kitTo === 'Berverly Porter');

		if (!kits[e.kitFrom]) {
			var nameFrom = (d.name1 || d.name || d.NAME || d.Name || "");
			var emailFrom = (d.email1 || "");
			kits[e.kitFrom] = {
				"kit": e.kitFrom,
				"name": nameFrom,
        outlineColour: cat20(e.kitFrom),
        kits:{},
			};
      if (emailFrom){
				kits[e.kitFrom].email = emailFrom;
      }
		}
		if (!kits[e.kitTo]) {
			var nameTo = d.name2 || d.Match || d["MATCHNAME"] || d["Match name"] || d["Display Name"] || "";
			var emailTo = (d.email2 || "");
			var color = d.color || d.Color || d.Colour || cat20(e.kitTo);
      var opacity = 0.25;
      var always = false;
			kits[e.kitTo] = {
				"kit": e.kitTo,
				"name": nameTo,
				"color": color,
        "opacity": opacity,
        kits:{},
			};
      if (emailTo){
        kits[e.kitTo].email = emailTo;
      }
		}
    kits[e.kitFrom].kits[e.kitTo] = kits[e.kitTo];
    
    // manually added column to help highlight or not...
    if (d.type){
      kits[e.kitTo].type = d.type;
      switch(kits[e.kitTo].type){
        case 'highlight':
          break;
        case 'ignore':
          break;
      }
    }

		e.row = 0;
		e.id = Math.random().toString(36);
    
    segids[e.id] = e;

		d = null;

    segments.push(e);
		return e;
	});
  
  return segments;
}

function rewriteData(id) {
	var csvdata = document.getElementById(id).value;
	var lines = csvdata.split("\n")

	if (lines[0] == "Comparison\tChrom.\tStart Position\tEnd Position\tGenetic Distance (cM)\tNumber of SNPs\tIdentity") {
		lines[0] = "NAME,MATCHNAME,chr,start,end,cm,snps,identity";
		for (var i=1; i<lines.length; i++) {
			lines[i] = lines[i].replace(" / ", "\t").split("\t").join(",");
		}
		document.getElementById(id).value = lines.join("\n")
	}
}

let startRSIDs = {};
let endRSIDs = {};

function loadData() {
	data = {};
	kits = {};
	filteredData = [];
  startRSIDs = {};
  endRSIDs = {};
  actions = [];
  
  let all = [];

	var j = 1;
	while (true) {
		var csvdata = document.getElementById('csvdata' + j);
		if (!csvdata) {
			break;
		}

		rewriteData('csvdata' + j);

		var raw = csvdata.value;
		var d = csvParse(raw);

		for (var i = 0; i < d.length; i++) {
			if (d[i].kitFrom == null) {
				continue;
			}
			data[d[i].kitFrom] = data[d[i].kitFrom] || [];
			data[d[i].kitFrom].push(d[i]);
      all.push(d[i]);
		}

		j++;
	}

  kits['all'] = {
    "kit": 'all',
    "name": 'all',
    "email": ''
  };
  kits['common'] = {
    "kit": 'common',
    "name": 'common',
    "email": ''
  };

  
  let common = [];
  let kitfroms = Object.keys(data);

  for (let i = 0; i < all.length; i++){
    let both = true;
    let seg = all[i];
    for (let j = 0; j < kitfroms.length; j++){
      if (kitfroms[j] === seg.kitTo){
        both = true;
        break;
      }
      if (!kits[kitfroms[j]].kits[seg.kitTo]){
        both = false;
      }
    }
    if (both){
      common.push(seg);
    }
  }
  
  data['all'] = all;
  data['common'] = common;
  
  
  getRSIDs();
  pruneRSIDs(startRSIDs);
  pruneRSIDs(endRSIDs);

	setOptions();
  
  doActions();
  
  //highlightKits();
  setHighlight();
}


var matchesMeta = {};

function loadMatchesData(){

  for (let i = 0; i < matchesData.length; i++){
    let data = matchesData[i];
    let matches = d3.csvParse(data, function (d, i) {
      return d;
    });
    
    for (let m = 0; m < matches.length; m++){
      let matchID = matches[m]['DNA Match ID'].split('-');
      let kitFrom = [];
      for (let i = 0; i < 6; i++){
        kitFrom.push(matchID.shift());
      }
      kitFrom = kitFrom.join('-');
      kitTo = matchID.join('-');
    
      matchesMeta[kitTo] = matches[m];
    }
  }
}

function getRSIDs(){
  for (let i = 0; i < data['all'].length; i++){
    let d = data['all'][i];
    if (d.startRSID){
//      let s = startRSIDs[d.kitFrom] = startRSIDs[d.kitFrom] || {};
      startRSIDs[d.startRSID] = startRSIDs[d.startRSID] || [];
      startRSIDs[d.startRSID].push(d);
    }
    if (d.endRSID){
//      let e = endRSIDs[d.kitFrom] = endRSIDs[d.kitFrom] || {};
      endRSIDs[d.endRSID] = endRSIDs[d.endRSID] || [];
      endRSIDs[d.endRSID].push(d);
    }
  }
}

function pruneRSIDs(source){
  let RSIDs = Object.keys(source);
  let srcKits = Object.keys(data);
  srcKits.pop(); // remove 'all'
  
  // remove segments which don't have any other common segments
  for (let i = 0; i < RSIDs.length; i++){
    let RSID = RSIDs[i];
    if (source[RSID].length === 1){
      delete source[RSID];
    }
  }

/*
  let k = Object.keys(source);
  
  let kit = k[0];
  for (let i = 1; i < k.length; i++){
    if (source[kit]){
      let RSIDs = Object.keys(source[kit]);
      for (let j = 0; j < RSIDs.length; j++){
        let RSID = RSIDs[j];
        if (source[k[i]]){
          if (source[k[i]][RSID]){
            console.log('common:', source[k[i]][RSID], source[kit][RSID]);
          } else {
            delete source[k[i]][RSID];
            delete source[kit][RSID];
          }
        }
      }
    }
  }
  */
}

let interestingsegs = {};

function getInterestingSegs(seg){
  interestingsegs = {};
  extractRSIDs(startRSIDs, 'start');
  extractRSIDs(endRSIDs, 'end');
  console.log(interestingsegs);
  downloadInterestingKits();

}

function extractRSIDs(source, type){
  let RSIDs = Object.keys(source);
  let srcKits = Object.keys(data);
  srcKits.pop(); // remove 'all'
  
  let srcsegs = [];
  // find segments from sourcekit[0]
  for (let i = 0; i < data['all'].length; i++){
    if (data['all'][i].kitTo === srcKits[0]){
      srcsegs.push(data['all'][i]);
    }
  }
  
  for (let i = 0; i < RSIDs.length; i++){
    let RSID = RSIDs[i];
    for (let s = 0; s < source[RSID].length; s++){
      let seg = source[RSID][s];
      seg.contained = false;
      for (let k = 0; k < srcsegs.length; k++){
        let srcseg = srcsegs[k];
        if (seg.chr === srcseg.chr){
          if (seg.start > srcseg.start && seg.start < srcseg.end){
            seg.contained = true;
          }
          if (seg.end > srcseg.start && seg.end < srcseg.end){
            seg.contained = true;
          }
        }
      }
      let kit = kits[seg.kitTo];
      if (kit.highlight || kit.type === 'highlight'){
        if (!interestingsegs[seg.kitTo]){
          kits[seg.kitTo].contained = false;
          interestingsegs[seg.kitTo] = { kit: kits[seg.kitTo], segs:[],startsegs:[], endsegs:[] };
        }
        let segtype = type + 'segs';
        interestingsegs[seg.kitTo][segtype].push(RSID);
        interestingsegs[seg.kitTo].segs.push(seg);
        if (seg.contained){
          interestingsegs[seg.kitTo].kit.contained = true;
        }
      }
    }
  }
  
}

function downloadInterestingKits(){
  let kits = [];
  let keys = Object.keys(interestingsegs);
  for (let i = 0; i < keys.length; i++){
    let out = {
      kit: keys[i],
      name: interestingsegs[keys[i]].kit.name,
      contained: interestingsegs[keys[i]].kit.contained,
      segcount: interestingsegs[keys[i]].segs.length,
      startsegs: interestingsegs[keys[i]].startsegs.toString(),
      endsegs: interestingsegs[keys[i]].endsegs.toString(),
    };
    kits.push(out);
  }

  // create CSV
  let csv = d3.csvFormat(kits);
  console.log(csv);

  download(csv, "interestingMatches.csv");
}
  
function download(content, filename, contentType)
{
  if(!contentType) contentType = 'application/octet-stream';
  var a = document.createElement('a');
  var blob = new Blob([content], {'type':contentType});
  a.href = window.URL.createObjectURL(blob);
  a.download = filename;
  a.click();
}



function setOptions() {
	var sel = d3.select("#fromkit").selectAll("option").data(Object.keys(data).map(x => kits[x]), function(d) {return d.kit;});
	sel.enter().append("option").attr("value", function (d) {
		return d.kit
	}).text(function (d) {
		return d.kit + (d.name != d.kit ? " " + d.name : "")
	});
	sel.exit().remove();
}

// https://en.wikipedia.org/wiki/Chromosome#Human_chromosomes
const chrlen = [0, 247199719, 242751149, 199446827, 191263063, 180837866, 170896993, 158821424, 146274826, 140442298, 135374737, 134452384, 132289534, 114127980, 106360585, 100338915, 88822254, 78654742, 76117153, 63806651, 62435965, 46944323, 49528953, 154913754];

function filterData(segments, includekits, excludekits, minCm, maxCm) {
  let org = filteredData;
	filteredData = [];
  
	if (segments.length == 0) {
		return;
	}

	var d = segments;

  let filteredsegs = [];
  
  for (let i = 0; i < d.length; i++){
    let e = d[i];
  
    // always include segs in the include list, regardless of min/max cm
    if (includekits.length > 0) {
      if (includekits.includes(e.kitTo)){
        filteredsegs.push(e);
        if (e.segdiv) e.segdiv.style.display = 'none';
        continue;
      }
    }
    if (e.cm < minCm){
      if (e.segdiv) e.segdiv.style.display = 'none';
      continue;
    }
    if (e.cm > maxCm){
      if (e.segdiv) e.segdiv.style.display = 'none';
      continue;
    }

    if (excludekits.length > 0) {
      if (excludekits.includes(e.kitTo)){
        if (e.segdiv) e.segdiv.style.display = 'none';
        continue;
      }
    }
    filteredsegs.push(e);
    if (e.segdiv) e.segdiv.style.display = 'block';
  }

	for (var i = 0; i <= 23; i++) {
    for (var j = 0; j < 3; j++) {
      var o = {
        "chr": i,
        "side": j,
        "segments": [],
        "div": (org && org[3*i + j]) ? org[3*i + j].div: null,
      };
      filteredData.push(o);
    }
	}

	for (var i = 0; i < filteredsegs.length; i++) {
		// filteredData[d[i].chr] = filteredData[d[i].chr] || {"segments": []};
		filteredData[3*filteredsegs[i].chr + filteredsegs[i].side].segments.push(filteredsegs[i]);
	}

	//filteredData = filteredData.filter(e => e.segments.length > 0);
}

function sortData(data, viewType) {
	var o = {};

	for (var i = 0; i < data.length; i++) {
		switch (viewType) {
		case "compact":
			o = compact(data[i].segments, compareSegment);
			break;
		case "compactreverse":
			o = compact(data[i].segments, compareSegmentReverse);
			break;
		case "kitsize":
			o = sortByKitSize(data[i].segments);
			break;
		case "segment":
			o = sortBySegment(data[i].segments, compareSegment);
			break;
		case "segmentreverse":
			o = sortBySegment(data[i].segments, compareSegmentReverse);
			break;
		}

		data[i].segments = o.data;
		data[i].numRows = o.numRows;
	}

	return data;
}


function getWidth() {
  return Math.max(
    document.body.scrollWidth,
    document.documentElement.scrollWidth,
    document.body.offsetWidth,
    document.documentElement.offsetWidth,
    document.documentElement.clientWidth
  );
}

var width = getWidth() * 0.8;

var tooltipDiv = document.getElementById('tooltip');

function mouseover(ev, d) {
  let name = "";
  let fromName = "";
  if (kits[d.kitTo].name !== d.kitTo) {
    name = " name " + kits[d.kitTo].name;
  }
  if (kits[d.kitFrom].name !== d.kitFrom) {
    fromName = " name " + kits[d.kitFrom].name;
  }
  tooltipDiv.style.opacity = 1.0;
  
  let str = 
    d.start.toLocaleString() + " to " + d.end.toLocaleString() + "<br>";
    
  if (d.startRSID){
    str += 'RSID: '+ d.startRSID + " to " + d.endRSID + "<br>";
  }
    
  str += "kitTo " + d.kitTo + name + "<br/>"+
    "kitFrom " + d.kitFrom + fromName + "<br/>"+
    "This segment " + d.cm.toFixed(1) + " cM";
    
  tooltipDiv.innerHTML = str;
  tooltipDiv.style.left = (ev.pageX + 40) + "px";
  tooltipDiv.style.top = (ev.pageY - 28) + "px";
  console.log(d.start + " to " + d.end + " kit [" + d.kitTo + "] name " + d.name);
}

function mouseover2(ev) {
  let name = "";
  let fromName = "";
  
  let d;
  for (let i = 0; i < data['all'].length; i++){
    if (data['all'][i].id === event.target.id){
      d = data['all'][i];
      break;
    }
  }
  
  if (!d){
    console.log('seg not found');
    return;
  }
  
  if (kits[d.kitTo].name !== d.kitTo) {
    name = " name " + kits[d.kitTo].name;
  }
  if (kits[d.kitFrom].name !== d.kitFrom) {
    fromName = " name " + kits[d.kitFrom].name;
  }
  tooltipDiv.style.opacity = 1.0;
  
  let str = 
    d.start.toLocaleString() + " to " + d.end.toLocaleString() + "<br>";
    
  if (d.startRSID){
    str += 'RSID: '+ d.startRSID + " to " + d.endRSID + "<br>";
  }
    
  str += "kitTo " + d.kitTo + name + "<br/>"+
    "kitFrom " + d.kitFrom + fromName + "<br/>"+
    "This segment " + d.cm.toFixed(1) + " cM";

  if (startRSIDs[d.startRSID]){
    let sRSIDstr = '';
    for (let i = 0; i < startRSIDs[d.startRSID].length; i++){
      sRSIDstr += `<br/>startmatch: ${kits[startRSIDs[d.startRSID][i].kitTo].name}`;
    }
    str += sRSIDstr;
  }
  if (endRSIDs[d.endRSID]){
    let sRSIDstr = '';
    for (let i = 0; i < endRSIDs[d.endRSID].length; i++){
      sRSIDstr += `<br/>endmatch: ${kits[endRSIDs[d.endRSID][i].kitTo].name}`;
    }
    str += sRSIDstr;
  }
  

    
  tooltipDiv.innerHTML = str;
  tooltipDiv.style.left = (ev.pageX + 40) + "px";
  tooltipDiv.style.top = (ev.pageY - 28) + "px";
  console.log(d.start + " to " + d.end + " kit [" + d.kitTo + "] name " + d.name);
}

function mouseout() {
  tooltipDiv.style.opacity = 0;

}

function clickSeg(ev) {
  if (menuState){
    toggleMenuOff();
    return;
  }

	var segments = data['all'] || [];

  let id = ev.target.id;
  let kit;
  let seg;
  for (let s = 0; s < segments.length; s++){
    seg = segments[s];
    if (seg.id === id){
      console.log('clicked', seg);
      kit = seg.kitTo;
      break;
    }
  }

  if (seg && seg.segdiv){
    let highlighted = kits[kit].highlight;
    
    let enable = !highlighted;
    if (kits[seg.kitTo].type === 'highlighted'){
      enable = true;
    }
    
    highlightKit(kit, enable);
  }
}

function dblClickSeg(ev){
  let kit = getKitFromSeg(ev.target.id);
  highlightAllMatching(kit, true);
  setHighlight();
}


function highlightKit(kit, enable){
	var fromkit = document.getElementById("fromkit").value;
	var segments = data[fromkit] || [];
  
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    if (seg.kitTo === kit){
      if (seg.segdiv){
        if (!enable){
          seg.segdiv.style.opacity = 0.5;
          delete seg.color
          kits[seg.kitTo].opacity = 0.5;
          seg.highlight = false;
          kits[seg.kitTo].highlight = false;
        } else {
          seg.segdiv.style.opacity = 1;
          seg.color = kits[seg.kitTo].color = seg.segdiv.style.backgroundColor;
          kits[seg.kitTo].opacity = 1;
          seg.highlight = true;
          kits[seg.kitTo].highlight = true;
        }
      }
    }
  }
}

function getKitFromSeg(segid){
  return segids[segid].kitTo;
}


function doActions(){
  for (let i = 0; i < actions.length; i++){
    if (kits[actions[i].kit]){
      switch(actions[i].type){
        case 'highlight':
          highlightAllMatching(actions[i].kit, true);
          kits[actions[i].kit].type = 'highlight';
          break;
        case 'unhighlight':
          highlightAllMatching(actions[i].kit, false);
          kits[actions[i].kit].type = 'ignore';
          break;
        case 'ignore':
          //highlightAllMatching(actions[i].kit, false);
          kits[actions[i].kit].type = 'ignore';
          break;      
      }
    }
  }
}

function highlightKits(){
  let keys = Object.keys(kits);
  for (let i = 0; i < keys.length; i++){
    if (kits[keys[i]].type === 'highlight'){
      highlightAllMatching(keys[i], true);
    }
  }
  for (let i = 0; i < keys.length; i++){
    if (kits[keys[i]].type === 'ignore'){
      highlightAllMatching(keys[i], false);
    }
  }
}

function highlightAllMatching(kit, enable){
	var segments = data['all'] || [];

  let kitsegs = {};
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    if (seg.kitTo === kit){
      kitsegs[seg.chr] = kitsegs[seg.chr] || [];
      kitsegs[seg.chr].push(seg);
    }
  }
  
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    if (kitsegs[seg.chr]){
      for (let i = 0; i < kitsegs[seg.chr].length; i++){
        let ks = kitsegs[seg.chr][i];
        if ((seg.start < ks.start && seg.end > ks.start) ||
            (seg.start < ks.end && seg.end > ks.end) ||
            (seg.start >= ks.start && seg.end <= ks.end)){
          if ((enable || kits[seg.kitTo].type === 'highlight') && (kits[seg.kitTo].type !== 'ignore')){
            kits[seg.kitTo].highlight = true;
          } else {
            if (kits[seg.kitTo].type !== 'highlight'){
              if (seg.kitTo === 'D-9901AC20-79C0-438F-98CA-AB11FEFE1876'){
                let here = true;
              }
              kits[seg.kitTo].highlight = false;
            }
          }
        }
      }
    }
  }

}

function setHighlight(){
	var segments = data['all'] || [];
  // highlight segs from kit highlight only.
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    seg.highlight = kits[seg.kitTo].highlight;
    let opacity = seg.highlight? 1.0:0.5;
    if (seg.segdiv && (+seg.segdiv.style.opacity) != opacity){
      seg.segdiv.style.opacity = opacity;
    }
    kits[seg.kitTo].opacity = opacity;
  }
}


function addSegments(div, chrom, chrsize) {

	var segmentHeight = +document.getElementById("segmentHeight").value;

	var sc = (len)=>{
    let newlen = (len/chrlen[chrom.chr])*chrsize;
    return newlen;
  };

  for (let s = 0; s < chrom.segments.length; s++){
    let d = chrom.segments[s];
    let newdiv = d.segdiv;
    let isnew = false;
    if (!newdiv){
      newdiv = document.createElement('DIV');
      newdiv.id = d.id;
      isnew = true;
    }
    d.segdiv = newdiv;
    newdiv.style.width = (sc(d.end) - sc(d.start)) + 'px';
    newdiv.style.height = segmentHeight + 'px'
    newdiv.style.top = (1 + d.row * (segmentHeight + 1)) + 'px';
    newdiv.style.left = sc(d.start) + 'px';
    newdiv.style.opacity = kits[d.kitTo].opacity;
    newdiv.style.display = 'block';
    
    if (isnew) {
      newdiv.style.margin = '';
      newdiv.style.padding = '';
      newdiv.style.border = '';
      newdiv.style.overflow = 'hidden';
      newdiv.innerHTML = kits[d.kitTo].name || d.kitTo;
      newdiv.style.outline =  '1px solid '+kits[d.kitFrom].outlineColour;
      newdiv.style.position = 'absolute';
      newdiv.style.backgroundColor = kits[d.kitTo].color;

      newdiv.addEventListener('mouseover', mouseover2);//(event) => {mouseover(event, d);});
      newdiv.addEventListener('mouseout', mouseout);
    }
    div.append(newdiv);
  }
  
/*
  rectangleAttributesEnter.append("rect")
		.attr("class", "segment")
		.on("mouseover", function (d) {
			name = "";
			if (kits[d.kitTo].name !== d.kitTo) {
				name = "<br>name " + kits[d.kitTo].name;
			}
			div.transition()
			.duration(200)
			.style("opacity", 1.0);
			div.html(d.start.toLocaleString() + " to " + d.end.toLocaleString() + "<br>kit " + d.kitTo + name + "<br/>This segment " + d.cm.toFixed(1) + " cM")
			.style("left", (d3.event.pageX + 40) + "px")
			.style("top", (d3.event.pageY - 28) + "px");
			console.log(d.start + " to " + d.end + " kit [" + d.kitTo + "] name " + d.name);
		})
		.on("mouseout", function (d) {
			div.transition()
			.duration(500)
			.style("opacity", 0);
		});
*/
}



function getChrBoxWidth(chr, chrsize) {
	if (chrsize === 'proportional') {
		return width * chrlen[chr] / chrlen[1];
	}

	return width;
}

function updateCm() {
	let minCm = +document.getElementById("minCm").value || 10;
	document.getElementById("minCm").value = minCm;

	let maxCm = +document.getElementById("maxCm").value || "";
	document.getElementById("maxCm").value = maxCm;

	var params = new URLSearchParams(location.search);
	if (params.has("minCm") || minCm != 10) {
		params.set("minCm", minCm);
	}
	if (params.has("maxCm") || maxCm !== "") {
		params.set("maxCm", maxCm);
	}

	window.history.replaceState({}, '', `${location.pathname}?${params}${window.location.hash}`);

	updateAll();
}

function updateAll() {
	updateData();
  updateDivDisplay();
}


var filteredByChr;

function updateDivDisplay() {
	var viewType = document.getElementById("viewtype").value;
	var chrview = +document.getElementById("chrview").value;
	var segmentHeight = +document.getElementById("segmentHeight").value;
	var chrsize = document.getElementById("chrsize").value;
  var hideuncoloured = document.getElementById("hideuncoloured").value;
  
	var rootDiv = document.getElementById("divchrbrowser");
  rootDiv.innerHTML = '';

	var fromkit = document.getElementById("fromkit").value;
	let segments = data[fromkit] || [];
  
  let kits = Object.keys(data);
  for (let k = 0; k < kits.length; k++){
    let segs = data[kits[k]] || [];
    // hide all segments which have divs - we may filter them out and they would remain.
    for (let i = 0; i < segs.length; i++){
      if (segs[i].segdiv){
        segs[i].segdiv.style.display = 'none';
      }
    }
  }

  // hide existing chromosome boxes
  if (filteredByChr){
    for (let i = 0; i < filteredByChr.length; i++){
      let chrom = filteredByChr[i];
      if (chrom.div){
        chrom.div.style.display = 'none';
        chrom.div.innerHTML = '';
      }
    }
  }
  
	filteredByChr = filteredData;
	if (chrview != 0 ) {
		filteredByChr = filteredData.filter(e => e.chr == chrview);
	}
  
  if (hideuncoloured === 'coloured'){
    for (let i = 0; i < filteredByChr.length; i++){
      let chrom = filteredByChr[i];
      let newsegs = [];
      for (let s = 0; s < chrom.segments.length; s++){
        let seg = chrom.segments[s];
        if (seg.highlight){
          newsegs.push(seg);
        }
      }
      chrom.segments = newsegs;
    }
  }
  
	filteredByChr = sortData(filteredByChr, viewType);

	// Create chromosomes
  let y = 0;
  for (let i = 0; i < filteredByChr.length; i++){
    let chrom = filteredByChr[i];
    if (chrom.segments.length){
      let newdiv = chrom.div;
      let isnew = false;
      if (!newdiv){
        newdiv = document.createElement('DIV');
        chrom.div = newdiv;
        isnew = true;
      }
      newdiv.id = `chrdiv${chrom.chr}_${chrom.side}`;
      newdiv.style.width = getChrBoxWidth(chrom.chr, chrsize) + 'px';
      newdiv.style.height = 1 + chrom.numRows * (segmentHeight + 1) + 'px'
      newdiv.style.top = y + 'px';
      newdiv.style.left = 20 + 'px';
      newdiv.style.position = 'absolute';
      newdiv.style.border = '2px solid black';
      newdiv.style.margin = '';
      newdiv.style.padding = '';
      newdiv.addEventListener('click', clickSeg);
      newdiv.addEventListener('dblclick', dblClickSeg);
      newdiv.addEventListener('contextmenu', contextMenu);
//      newdiv.ondblclick="dblClickSeg(event);";
  //    newdiv.oncontextmenu="contextMenu(event);";

      // only display if not filtered by chromosome
      if (chrview && (chrom.chr != chrview)){
        newdiv.style.display = 'none';
      } else {
        y += 1 + chrom.numRows * (segmentHeight + 1);
        newdiv.style.display = 'block';
      }
      
      if (isnew){
        let label = document.createElement('DIV');
        label.style.position = 'absolute';
        label.style.left = -20 + 'px';
        label.innerHTML = (chrom.chr == 23) ? 'X' : `${chrom.chr}`
        newdiv.append(label);
      }
      rootDiv.append(newdiv);
      
      // create segments 
      addSegments(newdiv, chrom, getChrBoxWidth(chrom.chr, chrsize));
    }
  }
  
  setHighlight();
}

function updateViewType(){
	var viewType = document.getElementById("viewtype").value;
	filteredByChr = sortData(filteredByChr, viewType);
  updatePosn();
}

function updateHidden(){
  updateData();
  updateDivDisplay();
}

function updatePosn(){
	var viewType = document.getElementById("viewtype").value;
	var chrview = +document.getElementById("chrview").value;
	var segmentHeight = +document.getElementById("segmentHeight").value;
	var chrsize = document.getElementById("chrsize").value;
  

  let y = 0;
  for (let i = 0; i < filteredByChr.length; i++){
    let chrom = filteredByChr[i];
    if (chrom.div){
      let chromwidth = getChrBoxWidth(chrom.chr, chrsize);
      var sc = (len)=>{
        let newlen = (len/chrlen[chrom.chr])*chromwidth;
        return newlen;
      };
      let height = 1 + chrom.numRows * (segmentHeight + 1) + 'px'
      let top = y + 'px';
      y += 1 + chrom.numRows * (segmentHeight + 1);

      if (chrom.div.style.width !== chromwidth + 'px') chrom.div.style.width = chromwidth + 'px';
      if (chrom.div.style.height !== height) chrom.div.style.height = height;
      if (chrom.div.style.top !== top) chrom.div.style.top = top;
      for (let s = 0; s < chrom.segments.length; s++){
        let d = chrom.segments[s];
        if (d.segdiv){
          let width = (sc(d.end) - sc(d.start)) + 'px';
          let height = segmentHeight + 'px'
          let top = (1 + d.row * (segmentHeight + 1)) + 'px';
          let left = sc(d.start) + 'px';
          if (d.segdiv.style.top !== top) d.segdiv.style.top = top;
          if (d.segdiv.style.height !== height) d.segdiv.style.height = height;
          if (d.segdiv.style.width !== width) d.segdiv.style.width = width;
          if (d.segdiv.style.left !== left) d.segdiv.style.left = left;
        }
      }
    }
  }
    
}



function updateData() {
	var fromkit = document.getElementById("fromkit").value;
	var includekits = document.getElementById("includekits").value.split('\n').filter(e => e.length > 0);
	var excludekits = document.getElementById("excludekits").value.split('\n').filter(e => e.length > 0);
	var minCm = document.getElementById("minCm").value || 5;
	var maxCm = document.getElementById("maxCm").value || 1000;

	var segments = data[fromkit] || [];
	filterData(segments, includekits, excludekits, minCm, maxCm);
}

function dragOverHandler(ev) {
	// Prevent default behavior (Prevent file from being opened)
	ev.preventDefault();
}

function loadFile(fileitem, resolve, reject) {
	var file = fileitem;
	var reader = new FileReader();
	reader.onloadend = function () {
		addCsvInput().value = reader.result;
		resolve('');
	}
	reader.onerror = function () {
		reject(arguments);
	}
	reader.readAsText(file);
}

var matchesData = [];

function loadFile2(fileitem, resolve, reject) {
	var file = fileitem;
	var reader = new FileReader();
	reader.onloadend = function () {
		matchesData.push(reader.result);
		resolve('');
	}
	reader.onerror = function () {
		reject(arguments);
	}
	reader.readAsText(file);
}

function dropHandler(ev) {
	// Prevent default behavior (Prevent file from being opened)
	ev.preventDefault();

	var tasks = [];

	if (ev.dataTransfer.items) {
		// Use DataTransferItemList interface to access the file(s)
		for (var i = 0; i < ev.dataTransfer.items.length; i++) {
			// If dropped items aren't files, reject them
			if (ev.dataTransfer.items[i].kind === 'file') {
				var t = new Promise((resolve, reject) => {
						loadFile(ev.dataTransfer.items[i].getAsFile(), resolve, reject);
					});
				tasks.push(t);
			}
		}
	} else {
		// Use DataTransfer interface to access the file(s)
		for (var i = 0; i < ev.dataTransfer.files.length; i++) {
			// console .log('... file[' + i + '].name = ' + ev.dataTransfer.files[i].name);
		}
	}

	// Pass event to removeDragData for cleanup
	removeDragData(ev)

	// Once all files are loaded
	Promise.all(tasks).then((msg) => {
		loadData();
		updateAll();
	});
}

function dropHandler2(ev) {
	// Prevent default behavior (Prevent file from being opened)
	ev.preventDefault();

	var tasks = [];

	if (ev.dataTransfer.items) {
		// Use DataTransferItemList interface to access the file(s)
		for (var i = 0; i < ev.dataTransfer.items.length; i++) {
			// If dropped items aren't files, reject them
			if (ev.dataTransfer.items[i].kind === 'file') {
				var t = new Promise((resolve, reject) => {
						loadFile2(ev.dataTransfer.items[i].getAsFile(), resolve, reject);
					});
				tasks.push(t);
			}
		}
	} else {
		// Use DataTransfer interface to access the file(s)
		for (var i = 0; i < ev.dataTransfer.files.length; i++) {
			// console .log('... file[' + i + '].name = ' + ev.dataTransfer.files[i].name);
		}
	}

	// Pass event to removeDragData for cleanup
	removeDragData(ev)

	// Once all files are loaded
	Promise.all(tasks).then((msg) => {
		loadMatchesData();
		//updateAll();
	});
}

function removeDragData(ev) {
	if (ev.dataTransfer.items) {
		// Use DataTransferItemList interface to remove the drag data
		ev.dataTransfer.items.clear();
	} else {
		// Use DataTransfer interface to remove the drag data
		ev.dataTransfer.clearData();
	}
}

function addCsvInput() {
	var div = document.getElementById("csvdatadiv");
	var num = div.children.length;
	var node = document.getElementById("csvdiv0").cloneNode(true);
	node.id = "csvdiv" + num;
	node.children[2].htmlFor = "csvdata" + num;
	node.children[4].id = "csvdata" + num;
	node.children[4].name = "csvdata" + num;
	div.appendChild(node);
	return node.children[4];
}

function addCsvInput2() {
	var div = document.getElementById("csvdatadiv");
	var num = div.children.length;
	var node = document.getElementById("csvdiv0").cloneNode(true);
	node.id = "csvdiv" + num;
	node.children[2].htmlFor = "csvdata" + num;
	node.children[4].id = "csvdata" + num;
	node.children[4].name = "csvdata" + num;
	div.appendChild(node);
	return node.children[4];
}

function showdiv(id) {
	var currentStyle = d3.select("#" + id).attr("style");
	if (currentStyle === 'display: block;') {
		d3.select("#" + id).attr("style", "display: none;");
	} else {
		d3.select("#data").attr("style", "display: none;");
		d3.select("#filters").attr("style", "display: none;");
		d3.select("#display").attr("style", "display: none;");
		d3.select("#about").attr("style", "display: none;");
		if (id !== 'none') {
			d3.select("#" + id).attr("style", "display: block;");
		}
	}
}

function onFileSelect(e) {
	if (!e.files) {
		return;
	}

	loadAll(e.files, loadFile);
}

function loadAll(arr, f) {
	var tasks = [];

	for (var i=0; i<arr.length; i++) {
		console.log(arr[i]);
		var t = new Promise((resolve, reject) => {
			f(arr[i], resolve, reject);
		});
		tasks.push(t);
	}

	// Once all files are loaded
	Promise.all(tasks).then((msg) => {
		loadData();
		updateAll();
	});
}

function loadURL(url, resolve, reject) {
	d3.text(url, function (error, data) {
			if (error) {
				reject(url + error);
			}
			addCsvInput().value = data;
			resolve('');
		});
}

function pageLoad() {
	var urls = [];

	if (typeof URLSearchParams === 'undefined') {
		if (window.location.search.startsWith("?url=")) {
			urls.push(window.location.search.substring(5));
		}
	} else {
		var params = new URLSearchParams(location.search);
		urls = params.getAll("url");

		let minCm = +params.get("minCm");
		if (minCm > 0 && minCm < 200) {
			document.getElementById("minCm").value = minCm;
		}

		let maxCm = +params.get("maxCm");
		if (maxCm > 0 && maxCm < 200) {
			document.getElementById("maxCm").value = maxCm;
		}
	}

	if (urls.length > 0) {
		loadAll(urls, loadURL);
	}

	var h = window.location.hash;
	if (h === '#Filters') {
		showdiv('filters');
	} else if (h === '#Display') {
		showdiv('display');
	} else if (h === '#none') {
		showdiv('none');
	} else {
		showdiv('data');
	}
}

pageLoad();

</script>
	</body>
</html>
