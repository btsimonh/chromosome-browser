<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Yulvil/btsimonh Chromosome Browser</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsstore@1.5.2"></script>
    <style>
div.tooltip {
    display:none;
    position: fixed;
    text-align: left;
    padding: 10px;
    font: 12px sans-serif;
    background: lightsteelblue;
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
    z-index: 2000;
}

textarea {
    width: 100%;
    // height: 55px;
}

.drop_zone {
	border: 2px dashed #000;
	width:  250px;
	height: 100px;
	float: left;
	text-align: center;
	margin: 0px 20px 0px 0px;
}
.filenames {
	border: 2px dashed #000;
	width:  450px;
	height: 300px;
	float: left;
	margin: 0px 20px 0px 0px;
}

.notescontainer {
  display: inline-grid;
  grid-template-columns: auto auto auto;
}

.notes {
	border: 2px dashed #000;
	width:  25vw;
	height: 300px;
	margin: 0px 20px 0px 0px;
  overflow: scroll;
}

input[type=number]{
    width: 70px;
	font-size: 16px;
	text-align: center;
	font-weight: bold;
}

#csvdiv0 {
	display: none;
}

body {
	margin: 0;
}

#topdiv {
	position: static;
	padding: 10px;
}

header {
	margin: 0;
	padding: 0;
	overflow: hidden;
}

nav ul {
	background-color: #333;
	list-style-type: none;
	margin: 0;
	padding: 0;
	overflow: hidden;
}

nav li {
	float: left;
}

nav li a {
	display: block;
	color: white;
	text-align: center;
	padding: 14px 16px;
	text-decoration: none;
}

nav li span {
	display: block;
	color: white;
	text-align: center;
	padding: 14px 16px;
	text-decoration: none;
}

/* Change the link color to #111 (black) on hover */
nav li a:hover {
	background-color: #111;
}

nav li span:hover {
	background-color: #111;
}

nav .active {
	background-color: #4CAF50;
}

nav {
	margin: 0;
	position: sticky;
	top: 0;
	right: 0;
	left: 0;
	z-index: 1000;
}

.inputs {
	display: none;
	padding: 10px;
}

.submenu {
	background-color: #555;
	color: white;
}

.chrbrowser {
  background:white;
	padding: 5px;
}
.chrbox {
}

a:link, a:visited {
	color: blue;
	font-weight: bold;
}

.headermenu a:link, .headermenu a:visited {
	color: yellow;
	font-weight: bold;
}

.clickable {
  cursor: pointer;

}

.surnameslist {
  overflow: scroll;
  height: 50vh;
}

.cornerx {
  position: absolute;
  right: 10px;
  top:10px;
  
}

.container {
  height:70vh;
}

.segment {
  padding: 0;
  margin: 0;
  border: 0;
  overflow: hidden;
  position: absolute;
  white-space: nowrap;
  padding-left:1ch;
  border-radius: 2px;
  cursor: pointer;
}

.hastree::before {
  content: "#";
  position: absolute;
  color: white;
  left:0;
}

.marked::after {
  content: "#";
  position: absolute;
  right:0;
  color: lime;
}

.draggable {
  
}

.wait {
  display: none;
  position: fixed;
  top:5vh;
  height:90vh;
  left:5vw;
  width:90vw;
  z-index: 1200;
  padding: 2px 0;
  background-color: #fff;
  border: solid 1px #dfdfdf;
  box-shadow: 1px 1px 2px #cfcfcf;
}


/* context menu */

.context-menu {
  display: none;
  position: relative;
  z-index: 10;
  padding: 2px 0;
  width: 90vw;
  background-color: #fff;
  border: solid 1px #dfdfdf;
  box-shadow: 1px 1px 2px #cfcfcf;
  border-radius: 0.5em;
}

.context-menuheader {
  width:100%; 
  background-color:yellow;
  cursor: pointer;
  margin-block-start: 0;
}

.context-menu--active {
  display: block;
}

.context-menu__items {
  list-style: none;
  margin: 0;
  padding: 0;
}

.context-menu__item {
  display: block;
  margin-bottom: 4px;
}

.context-menu__item:last-child {
  margin-bottom: 0;
}

.context-menu__link {
  display: block;
  padding: 4px 12px;
  color: #0066aa;
  text-decoration: none;
}

.context-menu__link:hover {
  color: #fff;
  background-color: #0066aa;
}

.chrom {
  background: repeating-linear-gradient(
    45deg,
    rgba(0, 0, 0, 0.2),
    rgba(0, 0, 0, 0.2) 10px,
    rgba(0, 0, 0, 0.3) 10px,
    rgba(0, 0, 0, 0.3) 20px
  );
  border:2px solid black;
  margin: 0;
  padding: 0;
  transform: translate(20px, 0px);
  border-radius: 4px;
  cursor: grab;
}

.fillbrowser {
  height: 100vh;
  width: 100vw;
}

.headermenu {
  height: 50px;
}

.fillremainder {
  width:100%;
  overflow: scroll;
  height: calc(100vh - 50px);
}

.overlay {
  position: absolute;
  left:5%;
  width:90%;
  z-index: 100;
}

    </style>
  </head>
  <body onkeydown="chrombrowser.keydown(event);">

    <header>
    </header>

    <div class="fillbrowser" onclick="chrombrowser.clickout(event);">
      <div class="tooltip" id="tooltip"></div>
      <div class="headermenu">
        <nav>
          <ul>
            <li><a href="#" onclick="chrombrowser.showdiv(event, 'none');">Yulvil Chromosome Browser</a></li>
            <li><a href="#Data" onclick="chrombrowser.showdiv(event, 'data');">Data</a></li>
            <li><a href="#Filters" onclick="chrombrowser.showdiv(event, 'filters');">Filters</a></li>
            <li><a href="#Display" onclick="chrombrowser.showdiv(event, 'display');">Display</a></li>
            <li><a href="#Surnames" onclick="chrombrowser.showdiv(event, 'surnameslist');">Surnames</a></li>
            <li><span onclick="chrombrowser.wrapFn(async ()=>{await chrombrowser.saveToDbjson();});" id="filename">Save</span></li>
            <li><span onclick="chrombrowser.wrapFn(async ()=>{await chrombrowser.saveToDbjson(true);});" id="filename">SaveAs</span></li>
            <li><a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a></li>
            <li style="float: right"><a href="#" onclick="chrombrowser.showdiv(event, 'about');">About</a></li>
          </ul>
        </nav>
      </div>
      <div class="overlay">
        <form id="myform" onsubmit="return false;" onclick="event.stopPropagation();">
            <div class="submenu">
              <div class="inputs" id="none">
                <a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a><br/>
              </div>
              <div class="inputs" id="data">
                <a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a><br/>
                <div style="width: 100%; overflow: hidden;">

                <div class="drop_zone" ondrop="chrombrowser.dropHandler(event);" ondragover="chrombrowser.dragOverHandler(event);">
                  <p>&#128193; Drag one or more files here</p>
                </div>

                <div class="filenames" id="filenames" contenteditable="true"></div>
                

                <div>
                  <div id="recentfiles" title="Recent files, click a button to load one"></div>
                </div>
                <div>
                  <span>Ancestry URL:</span><input size=40 type="text" id="ancestryurl">
                </div>
                <div id="totalsegments">
                </div>
                  
              </div>
            </div>
            <div class="inputs" id="filters">
              <a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a><br/>
              <label for="minCm">Centimorgan size</label>
              from <input id="minCm" type="number" value="10" 
                onChange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updateCm();});">
                <!--onInput="chrombrowser.wrapFn(async ()=>{await chrombrowser.updateCm();});">-->
              to <input id="maxCm" type="number" value="" onChange="chrombrowser.updateCm();" onInput="chrombrowser.updateCm();">

              <br/><br/>
              <label for="includekits">Only show these kits (one per line)</label>
              <br/>
              <textarea name="includekits" id="includekits" onChange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updateAll();});"></textarea>

              <br/><br/>
              <label for="excludekits">Exclude these kits (one per line)</label>
              <br/>
              <textarea name="excludekits" id="excludekits" onChange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updateAll();});"></textarea>
            </div>
            <div class="inputs" id="display">
              <a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a><br/>
              <label for="chrview">Chromosome</label>
              <select id="chrview" onChange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updateAll();});">
                <option value="0">All</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
                <option value="12">12</option>
                <option value="13">13</option>
                <option value="14">14</option>
                <option value="15">15</option>
                <option value="16">16</option>
                <option value="17">17</option>
                <option value="18">18</option>
                <option value="19">19</option>
                <option value="20">20</option>
                <option value="21">21</option>
                <option value="22">22</option>
                <option value="23">X</option>
              </select>

              <br/><br/>
              <label for="chrsize">Chromosome Size</label>
              <select id="chrsize" onchange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updatePosn();});">
                <option value="screenwidth" selected="selected">screen width</option>
                <option value="proportional">proportional</option>
              </select>
              <label for="screenwidth">Screen Width</label>
              <select id="screenwidth" onchange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updatePosn();});">
                <option value="0" selected="selected">browser width</option>
                <option value="1920">1920 pixels</option>
                <option value="4000">4000 pixels</option>
                <option value="10000">10000 pixels</option>
              </select>

              <label for="nametype">Name type</label>
              <select id="nametype" onchange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updatePosn();});">
                <option value="name" selected="selected">name</option>
                <option value="kit">kit id</option>
                <option value="index">index</option>
              </select>

              <br/><br/>
              <label for="viewtype">View Type</label>
              <select id="viewtype" onchange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updateViewType();});">
                <option value="compact" selected="selected">Compact</option>
                <option value="compactreverse">Compact (reverse)</option>
                <option value="segment">By Segment</option>
                <option value="segmentreverse">By Segment (reverse)</option>
              <!--
                <option value="kitsize">By Kit Size</option>
              -->
              </select>
              <br/><br/>
              <label for="segmentHeight">Segment Height</label>
              <input id="segmentHeight" type="number" value="20" onChange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updatePosn();});">

              <br/><br/>
              <label for="fromkit">Active Kit</label>
              <select id="fromkit" onchange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updateAll();});">
              </select>

              <br/><br/>
              <button onclick="chrombrowser.showhidden(false);">Show only Higlights</button>
              <button onclick="chrombrowser.showhidden(true);">Show All</button>

              <label style="display:none;" for="hideuncoloured">Show Segments</label>
              <select style="display:none;" id="hideuncoloured" onchange="chrombrowser.wrapFn(async ()=>{await chrombrowser.updateHidden();});">
                <option value="all" selected="selected">All</option>
                <option value="coloured">Solid Colour</option>
              </select>
              <br/><br/>
              <button onclick="chrombrowser.refresh();">Refresh</button>

            </div>
            <div class="inputs" id="surnameslist">
              <button onclick="chrombrowser.highlightAll(false);">Clear all Higlights</button>
              <button onclick="chrombrowser.showhidden(false);">Show only Higlights</button>
              <button onclick="chrombrowser.showhidden(true);">Show All</button>
              <div class="surnameslist" id="surnamelist"></div>
            </div>
            <div class="inputs" id="about">
              Copyright (c) 2018 yulvil, 2022 btsimonh <a href="https://github.com/btsimonh/chromosome-browser/wiki" target="_blank">Help</a> and <a href="https://github.com/btsimonh/chromosome-browser" target="_blank">Source Code</a>
              <div>Page views: <span id="visits">...</span></div>
              </div>
            </div>
          </nav>
        </form>
      </div>
      <div id="chrbrowsercontainer"  class="fillremainder container">
        <div id="divchrbrowser" style="position:relative;">
        </div>
        <nav id="context-menu" class="context-menu" onclick="event.stopPropagation();">
          <p id="context-menuheader" class="context-menuheader"><b id="fullname"></b></p>
          <p id="selectedsegment"></p>
          <span>KitTag:</span><input type="text" id="kittag">
          <br/>
          <span>SegTag:</span><input type="text" id="segtag">
          <br/>
          <span>Ancestry Kit ID:</span><input type="text" id="ancestryid">
          <br/>
          <span>GedMatch Kit ID:</span><input type="text" id="gedmatchid">
          <br/>
          <span style="display:inline-block; width:10%;">Mark Seg:</span>
          <input type="checkbox" id="markseg"/>
          <span style="display:inline-block; width:10%;">Mark Kit:</span>
          <input type="checkbox" id="markkit"/>
          <br/>
          <span style="display:inline-block; width:10%;">Highlight:</span>
            <button onclick="chrombrowser.menuClick(event, 0)">All kit matches</button>
            <button onclick="chrombrowser.menuClick(event, 11)">All seg matches</button>
            <button onclick="chrombrowser.menuClick(event, 9)">All</button>
            <button onclick="chrombrowser.menuClick(event, 7)">All kit</button>
            <button onclick="chrombrowser.menuClick(event, 20)">This Seg</button>
          <br/>
          <span style="display:inline-block; width:10%;">un-Highlight:</span>
            <button onclick="chrombrowser.menuClick(event, 1)">All kit matches</button>
            <button onclick="chrombrowser.menuClick(event, 12)">All seg matches</button>
            <button onclick="chrombrowser.menuClick(event, 10)">All</button>
            <button onclick="chrombrowser.menuClick(event, 8)">All kit</button>
            <button onclick="chrombrowser.menuClick(event, 21)">This Seg</button>
          <br/>
              <button onclick="chrombrowser.showhidden(false);">Show only Higlights</button>
              <button onclick="chrombrowser.showhidden(true);">Show All</button>
          <br/>
          
          <!--<button onclick="menuClick(event, 2)"> Download Interesting Matches</button><br/>-->
          <button onclick="chrombrowser.menuClick(event, 3)"> MH View Tree <span id="treecount">0</span></button>
          <button onclick="chrombrowser.menuClick(event, 4)"> MH Review Match</button>
          <br/>
          <button onclick="chrombrowser.menuClick(event, 13)"> Ancestry member search</button>
          <button onclick="chrombrowser.menuClick(event, 31)"> Ancestry Match Name Search</button>
          <span id="compare"></span>
          <br/>
          <span>Surnames:</span><input type="text" size=100 id="surnamesedit" title="You may edit the surnames accociated with this kit as a comma separated string"/><br/>

          <div class="notescontainer">
            <div>
              <span>Notes:</span><br/>
              <div class="notes" id="kitnotes" contenteditable="true" title="You may make notes against this kit here, e.g. add links to ancestry or other."></div>
            </div>
            
            <div>
              <span>Segments:</span><br/>
              <div class="notes" id="kitsegs" title="all segments from this kit"></div>
            </div>
            <div>
              <span>Surnames:<br/>
              <div class="notes" id="surnames" title="Lists surnames accociated with this kit, and the counts of displayed kits which have each surname.  The search link searches your Ancestry matches"></div>
            </div>
          </div>
          <button class="cornerx" onclick="chrombrowser.toggleMenuOff()">X</button>
        </nav>
      </div>  
    </div>
    <div class="wait" id="wait" style="display:none;"></div>
    <script type="module">
"use strict;";


// the raw data:
// all the segments.

// like:
// data = {
//   "srckitid1":[ { seg 1-1 },{ seg 1-2 },...], - segments from first source kit
//   "srckitid2":[ { seg 1-2 },{ seg 2-2 },...], - segments from second source kit
//   "all":[{ seg 1-1 },{ seg 1-2 },...,{ seg 1-2 },{ seg 2-2 },...], - all segments from all kits
//   "common":[{ seg 1-1 },...,{ seg 2-2 },...], - segments common to the first two source kits
// }
// a segment is like:
/*
{
  kitFrom: "kitid", - this is the source kit
  kitTo: "kitid", - this is the compared kit
  chr: 1-23, - chormosome of matched segment, X is 23
  start: number, - start point
  end: number, - end point
  startRSID: "start RSID", - if in input data
  endRSID: "end RSID", - if in input data
  cm: number, - cm of segment
  side: 0|1|2, - not in myHeritage data?
  id: "unique id", - used in div tracking
  mark: ""|"always"|"never", - control highlight of this segment.
  
  row: number, - calculated row position - recalculated on display change.
  highlight: true|false, - copied from kits[kitTo].
}
*/

import { get, set } from 'https://unpkg.com/idb-keyval@5.0.2/dist/esm/index.js';

var data = {};

var gzHandle;
var filename = '';

var matchesData = [];

var refreshAll = false;
var refreshCommon = false;

let selectedSeg;


// kits = {
//   "AZ123": {"name": "John Doe", "email": "a@b.c", "color": "..."},
// }
/*
{
    kit: "kit id",
    name: "name on kit",
    outlinecolour: "color", - color associated with source kit.
    kits:{ - kits this source kit matched with.
      "kitid1":true,
      "kitid2":true,
    },
    kitindex: number, - used to anonomyse display for image posting,
    email: "me@here", - if in data
    highlight: true|false
}
*/
var kits = {}; // - all kits including source kits.

var activeKits = {}; // kits displayed after filter

// match data - e.g. tree url, tree count, name, etc.
var matchesMeta = {};
// surname list with kits and count
var surnames = {};

// indexing
// segment id to segment lookup
var segids = {};
// segment id to div lookup
var segdivs = {};

// data after filter - used for display
var filteredData = [];
// final filtered data?
var filteredByChr;

// next kit iindex - used to anonomyse display
let kitindex = 0;

// segments by RSID
let startRSIDs = {};
let endRSIDs = {};

// dynamic created for download.
let interestingsegs = {};


let config = {
  viewtype: 'compact',
  chrview: 0,
  segmentHeight: 20,
  chrsize: 'screenwidth',
  screenwidth: 0,
  hideuncoloured: 'all',
  fromkit: 'all',
  nametype: 'name',
  includekits:[],
  excludekits: [],
  minCm: 5,
  maxCm: 1000,
  ancestryurl: 'www.ancestry.co.uk',
};



let recentFiles = null;


// global variables used:
// https://en.wikipedia.org/wiki/Chromosome#Human_chromosomes
const chrlen = [0, 247199719, 242751149, 199446827, 191263063, 180837866, 170896993, 158821424, 146274826, 140442298, 135374737, 134452384, 132289534, 114127980, 106360585, 100338915, 88822254, 78654742, 76117153, 63806651, 62435965, 46944323, 49528953, 154913754];

// this is used for the width of the chrom data overall!!!
var width = getWidth() * 0.95;

var tooltipDiv = document.getElementById('tooltip');


var contextMenuClassName = "context-menu";
var contextMenuItemClassName = "context-menu__item";
var contextMenuLinkClassName = "context-menu__link";
var contextMenuActive = "context-menu--active";
var menu = document.querySelector("#context-menu");
var menuItems = menu.querySelectorAll(".context-menu__item");
var menuState = 0;
var menuWidth;
var menuHeight;
var menuPosition;
var menuPositionX;
var menuPositionY;
var menuSegid;

var waitStartTime;
var times = [];


async function wrapFn(fn){
  await promiseStartWait('updating');
  await fn();
  await promiseEndWait();
}

function promiseStartWait(text) {
  return new Promise(resolve => {
    startWait(text);
    let inter = setInterval(()=>{
      let waitdlg = document.getElementById('wait');
      if (waitdlg.scrollWidth){
        clearInterval(inter);
        resolve('resolved');
      }
    }, 40);
  });
}

function promiseEndWait() {
  let waitdlg = document.getElementById('wait');
  let time = Date.now();
  let diff = time - waitStartTime;
  let text = 'endWait '+(diff/1000).toFixed(3);
  waitdlg.innerHTML += text;
  times.push(text);
  console.log(text);
  console.log(times);

  return new Promise(resolve => {
    setTimeout(() => {
      waitdlg.style.display = 'none';
      waitdlg.innerHTML = '';
      resolve('resolved');
    }, 1000);
  });
}

function startWait(text){
  console.log('startwait '+text);
  let waitdlg = document.getElementById('wait');
  if (waitdlg.style.display !== 'block'){
    waitdlg.style.display = 'block';
    waitStartTime = Date.now();
    times = [];
    console.log(text+' 0');
  } else {
    let time = Date.now();
    let diff = time - waitStartTime;
    text += ' '+(diff/1000).toFixed(3);
    times.push(text);
    console.log(text);
  }
  waitdlg.innerHTML = waitdlg.innerHTML + text + '<br/>';
}

function endWait(){
  let waitdlg = document.getElementById('wait');
  waitdlg.style.display = 'none';
  waitdlg.innerHTML = '';
  let time = Date.now();
  let diff = time - waitStartTime;
  let text = 'endWait '+(diff/1000).toFixed(3);
  times.push(text);
  console.log(text);
  console.log(times);
}

async function downloadjson(){
  readConfig();
  let downloaddata = { sources: {} };
  let datakeys = Object.keys(data);
  for (let i = 0; i < datakeys.length; i++){
    if (datakeys[i] !== 'all' && datakeys[i] !== 'common'){
      downloaddata.sources[datakeys[i]] = data[datakeys[i]];
    }
  }
  downloaddata.kits = kits;
  downloaddata.matchesMeta = matchesMeta;
  downloaddata.config = config;
  
  let gz = await compress(JSON.stringify(downloaddata, null, ' '));
  
  download(gz, "data.json.gz");
}

async function saveToDbjson(saveAs){
  readConfig();
  let filenames = getFilenames();

  if (!filename || saveAs){
    // create a new handle
    const opts = {
      excludeAcceptAllOption: true,
      suggestedName: 'chrombrowserdata.gz',
      types: [{
        description: 'gz File',
        accept: {'application/gzip': ['.gz']},
      }],
    };
    gzHandle = await window.showSaveFilePicker(opts);
    let file = await gzHandle.getFile();
    filename = file.name;
    document.getElementById('filename').innerHTML = "save <b>"+filename+"</b>";
    let x = await setExistingFile(filename);
  }

  await promiseStartWait('Saving '+filename);

  let status = await gzHandle.requestPermission({ mode : "readwrite" });
  
  let downloaddata = { sources: {} };
  let datakeys = Object.keys(data);
  for (let i = 0; i < datakeys.length; i++){
    if (datakeys[i] !== 'all' && !datakeys[i].startsWith('common')){
      downloaddata.sources[datakeys[i]] = data[datakeys[i]];
    }
  }
  downloaddata.kits = kits;
  downloaddata.matchesMeta = matchesMeta;
  downloaddata.notes = filenames;
  downloaddata.config = config;
  
  let gz = await compress(JSON.stringify(downloaddata, null, ' '));
  
  const writableStream = await gzHandle.createWritable();

  // write our file
  await writableStream.write(gz);

  // close the file and write the contents to disk.
  await writableStream.close();
}


// basic page counter; no informaton is sent to this server.
if (!document.URL.startsWith('file:')){
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "https://api.countapi.xyz/hit/btsimonh.github.io-chromosome-browser/visits");
  xhr.responseType = "json";
  xhr.onload = function() {
      document.getElementById('visits').innerText = this.response.value;
  }
  xhr.send();
} else {
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "https://api.countapi.xyz/get/btsimonh.github.io-chromosome-browser/visits");
  xhr.responseType = "json";
  xhr.onload = function() {
      document.getElementById('visits').innerText = this.response.value;
  }
  xhr.send();

}

var compareSegment = function (a, b) {
	if (a.start < b.start) {
		return -1;
	} else if (a.start > b.start) {
		return 1;
	}

	if (a.cm < b.cm) {
		return 1;
	} else if (a.cm > b.cm) {
		return -1;
	}

	return -a.id.localeCompare(b.id);
};

var compareSegmentReverse = function (a, b) {
	if (a.end > b.end) {
		return -1;
	} else if (a.end < b.end) {
		return 1;
	}

	if (a.cm < b.cm) {
		return 1;
	} else if (a.cm > b.cm) {
		return -1;
	}

	return -a.id.localeCompare(b.id);
};

function sortBySegment(data, fcmp) {
	var d = data.sort(fcmp);
	for (var i = 0; i < d.length; i++) {
		d[i].row = i;
	}

	return {
		"data": d,
		"numRows": data.length
	};
}

let contextkit;

function contextMenu(e) {
  e.stopPropagation();
  console.log('Context', e);
  let taskItemInContext = e.target;

  if ( taskItemInContext ) {
    e.preventDefault();
    menuSegid = taskItemInContext.id;
    
    dragElement(document.getElementById("context-menu"));

    let kit = getKitFromSeg(menuSegid);
    if (!kit) {
      clickout(e);
      return;
    }
    
    if (selectedSeg){
      segdivs[selectedSeg].style.color = 'black';
    }
    selectedSeg = menuSegid;
    segdivs[selectedSeg].style.color = 'red';

    let menuseg = segids[selectedSeg];
    

    contextkit = kit;
    let treecountel = document.getElementById('treecount');
    if (matchesMeta[kit] && matchesMeta[kit]['Number of individuals in the tree']){
        treecountel.innerHTML = matchesMeta[kit]['Number of individuals in the tree'];
    } else {
        treecountel.innerHTML = 'unknown';
    }
    
    let nameel = document.getElementById('fullname');
    nameel.innerHTML = kits[kit].name;
    
    let segel = document.getElementById('selectedsegment');
    segel.innerHTML = 
      kits[menuseg.kitFrom].name+': ' +
      menuseg.chr+': '+menuseg.start+'-'+menuseg.end+' '+menuseg.cm+'cM';
    
    let tagel = document.getElementById('kittag');
    tagel.value = kits[kit].tag || '';
    let segtagel = document.getElementById('segtag');
    segtagel.value = menuseg.tag || '';

    let ancestryidel = document.getElementById('ancestryid');
    ancestryidel.value = kits[kit].ancestryid || '';
    
    let gedmatchidel = document.getElementById('gedmatchid');
    gedmatchidel.value = kits[kit].gedmatchid || '';
    
    
    let notesel = document.getElementById('kitnotes');
    if (kits[kit] && kits[kit].notes){
      notesel.innerHTML = kits[kit].notes;
    } else {
      notesel.innerHTML = '';
    }
    let markkitsel = document.getElementById('markkit');
    if (kits[kit] && kits[kit].marked){
      markkitsel.checked = kits[kit].marked;
    } else {
      markkitsel.checked = false;
    }
    let marksegsel = document.getElementById('markseg');
    if (menuseg && menuseg.marked){
      marksegsel.checked = menuseg.marked;
    } else {
      marksegsel.checked = false;
    }
    
    let surnamesel = document.getElementById('surnames');
    let surnameseditsel = document.getElementById('surnamesedit');
    
    if (matchesMeta[kit]){
      let addsurnames = ()=>{
        if (matchesMeta[kit] && matchesMeta[kit]['All ancestral surnames']){
          surnameseditsel.value = matchesMeta[kit]['All ancestral surnames'];
          let ss = matchesMeta[kit]['All ancestral surnames'].split(',');
          let html = '';
          for (let i = 0; i < ss.length; i++){
            html += `<span class="clickable" title="click to higlight all kits with this surname" onclick="chrombrowser.highlightSurname('${ss[i]}', true);"><u>${ss[i]}</u></span>`;
            if (surnames[ss[i]]){
              html += `(${surnames[ss[i]].count})`;
            }
            if (kits[menuseg.kitFrom].ancestryid){
              html += ` <a target="_blank" title="click to search Ancestry matches of ${kits[menuseg.kitFrom].name} for this surname" href="'+getAncestrySurnameUrl(menuseg.kitFrom, ss[i])+'">&#x1F50E;</a>`;
            }
            html += '<br/>';
          }
          surnamesel.innerHTML = html;
        } else {
          surnamesel.innerHTML = '';
        }
      }
      
      surnameseditsel.onchange = ()=>{
        matchesMeta[kit]['All ancestral surnames'] = surnameseditsel.value.toLowerCase();
        addsurnames();
      };
      addsurnames();
      
      surnameseditsel.display = 'inline';
    } else {
      surnameseditsel.display = 'none';
    }
    
    let compareel = document.getElementById('compare');
    if (kits[menuseg.kitFrom].ancestryid && kits[kit].ancestryid){
      let html = `<a target="_blank" href="${getAncestryCompareUrl(menuseg.kitFrom, kit)}">Ancestry Compare ${kits[menuseg.kitFrom].name} with ${kits[kit].name}</a>`;
      compareel.innerHTML = html;
    } else {
      compareel.innerHTML = '';
    }
    
    let segsel = document.getElementById('kitsegs');
    if (kits[kit] && kits[kit].segs){
      let segs = Object.keys(kits[kit].segs);
      let txt = '';
      for (let i = 0; i < segs.length; i++){
        let seg = segids[segs[i]];
        txt += kits[seg.kitFrom].name+': ';
        txt += seg.chr+': '+seg.start+'-'+seg.end+' '+seg.cm+'cM';
        txt += '<br/>';
      }
      segsel.innerHTML = txt;
    } else {
      segsel.innerHTML = '';
    }
    
    let orgstate = toggleMenuOn();
    // don't re-position if already open, so that if if was dragged, it stays
    if (!orgstate){
      positionMenu(e);
    }
  } else {
    taskItemInContext = null;
    toggleMenuOff();
  }
}

 /**
   * Turns the custom context menu on.
   */
  function toggleMenuOn() {
    let orgstate = menuState;
    if ( menuState !== 1 ) {
      menuState = 1;
      menu.classList.add( contextMenuActive );
    }
    return orgstate;
  }

  /**
   * Turns the custom context menu off.
   */
  function toggleMenuOff() {
    if ( menuState !== 0 ) {
      menuState = 0;
      menu.classList.remove( contextMenuActive );
      let notesel = document.getElementById('kitnotes');
      let tagel = document.getElementById('kittag');
      let segtagel = document.getElementById('segtag');
      let ancestryidel = document.getElementById('ancestryid');
      let gedmatchidel = document.getElementById('gedmatchid');
      let markkitsel = document.getElementById('markkit');
      let marksegsel = document.getElementById('markseg');

      let segdiv = segdivs[selectedSeg];
      let seg = segids[selectedSeg];
      let setkits = false;
      let setKitMarked = false;
      if (kits[contextkit]){
        kits[contextkit].notes = notesel.innerHTML;
        if (tagel.value){
          if (kits[contextkit].tag !== tagel.value){
            setkits = true;
            kits[contextkit].tag = tagel.value;
          }
        } else {
          delete kits[contextkit].tag;
        }
        if (segtagel.value){
          segids[selectedSeg].tag = segtagel.value;
        } else {
          delete segids[selectedSeg].tag;
        }
        if (ancestryidel.value){
          kits[contextkit].ancestryid = ancestryidel.value;
        } else {
          delete kits[contextkit].ancestryid;
        }
        if (gedmatchidel.value){
          kits[contextkit].gedmatchid = gedmatchidel.value;
        } else {
          delete kits[contextkit].gedmatchid;
        }

        if (markkitsel.checked != kits[contextkit].marked){
          if (markkitsel.checked){
            kits[contextkit].marked = true;
          } else {
            delete kits[contextkit].marked;
          }
          setKitMarked = true;
        }
        if (marksegsel.checked != seg.marked) {
          if (marksegsel.checked){
            seg.marked = true;
            segdiv.classList.add('marked');
          } else {
            delete seg.marked;
            segdiv.classList.remove('marked');
          }
        }
        
        let prefix = tagel.value+segtagel.value;
        
        segdiv.innerHTML = prefix + (kits[seg.kitTo].name || seg.kitTo);
      }
      if (setkits){
        updatePosn();
      }
      if (setKitMarked){
        setHighlight();
      }
    }
  }

  /**
   * Positions the menu properly.
   * 
   * @param {Object} e The event
   */
  function positionMenu(e) {
    //let windowWidth = window.innerWidth;
    //let windowHeight = window.innerHeight;

    menu.style.position = 'fixed';
    menu.style.zIndex = 2000;
    menu.style.top = '5vh';
    menu.style.left = '5vw';
    menu.style.width = '90vw';
    menu.style.height = '90vh';
  }

function refresh() {
  width = getWidth() * 0.95;
  updateHidden();
  updatePosn();
}

function showhidden(enable){
  if (enable){
    config.hideuncoloured = 'all';
  } else {
    config.hideuncoloured = 'coloured';
  }
  setConfig();
  updateHidden();
}
  
function menuClick(ev, item){
  //toggleMenuOff();

  let segid = menuSegid;
  let kit = getKitFromSeg(segid);
  let seg = segids[segid];
  if (!kit) return;

  switch(item){
    case 0:
      highlightAllMatchingKit(kit, true);
      setHighlight();
      break;
    case 1:
      highlightAllMatchingKit(kit, false);
      setHighlight();
      break;
    case 2:
      getInterestingSegs(segid);
      break;
    case 3:{
      if (matchesMeta[kit]){
        let url = matchesMeta[kit]['View tree'];
        if (url){
          var a = document.createElement('a');
          a.href = url;
          a.target = '_Blank';
          a.click();
        }
      }
    } break;
    case 4:{
      if (matchesMeta[kit]){
        let url = matchesMeta[kit]['Review DNA Match page'];
        if (url){
          var a = document.createElement('a');
          a.href = url;
          a.target = '_Blank';
          a.click();
        }
      }
    } break;
    case 5:{
      highlightKit(kit, true);
    } break;
    case 6:{
      highlightKit(kit, false);
    } break;
    case 7:{
      highlightKit(kit, true);
    } break;
    case 8:{
      highlightKit(kit, false);
    } break;
    case 9:{
      highlightAll(true);
    } break;
    case 10:{
      highlightAll(false);
    } break;
    case 11:{
      highlightAllMatchingSeg(segid, true);
    } break;
    case 12:{
      highlightAllMatchingSeg(segid, false);
    } break;
    case 13:{
      ancestryMemberSearch(kits[kit].name);
    } break;
    
    // segment
    case 20:{
      if (seg){
        seg.mark = "always";
      }
      break;
    }
    case 21:{
      if (seg){
        seg.mark = "never";
      }
      break;
    }
    
    case 31:{
      if (kits[seg.kitFrom].ancestryid){
        searchAncestryMatchName(seg.kitFrom, kits[seg.kitTo].name);
      } else {
        alert('add an ancestry kit id to '+kits[seg.kitFrom].name);
      }
    } break;
  }
  setHighlight();
}

// unused and incorrect
function sortByKitSize(data) {
	var kits = {};
	var numRows = 0;

	for (var i = 0; i < data.length; i++) {
		if (data[i].kit in kits) {
			kits[data[i].kit].total += data[i].cm;
		} else {
			kits[data[i].kit] = {
				"total": data[i].cm
			};
		}
	}

	var compareFunc = function (a, b) {
		if (kits[a.kit].total < kits[b.kit].total) {
			return 1;
		} else if (kits[a.kit].total > kits[b.kit].total) {
			return -1;
		}
		return -a.kit.localeCompare(b.kit);
	}

	var d = data.sort(compareFunc)
		var currKit = d[0].kit;
	var currRow = 0;
	for (var i = 0; i < d.length; i++) {
		if (currKit !== d[i].kit) {
			currKit = d[i].kit;
			currRow++;
		}
		d[i].row = currRow;

		if (numRows < currRow + 1)
			numRows = currRow + 1;
	}

	return {
		"data": d,
		"numRows": numRows
	};
}

function compact(data, fcmp) {
	var numRows = 1;
	var d = data.sort(fcmp);

	function overlap(s1, s2) {
		if (s1.row == s2.row) {
			if ((s1.start <= s2.start && s2.start <= s1.end) ||
				(s1.start <= s2.end && s2.end <= s1.end)) {
				return true;
			}
		}
		return false;
	}

	function overlapPrevious(segments, until) {
		for (var i = 0; i < until; i++) {
			if (overlap(segments[i], segments[until])) {
				return true;
			}
		}

		return false;
	}

	for (var i = 0; i < d.length; i++) {
		var j = 0;
		d[i].row = j;
		while (j < i && overlapPrevious(d, i)) {
			j++;
			d[i].row = j;

			if (numRows < j + 1)
				numRows = j + 1;
		}
	}

	return {
		"data": d,
		"numRows": numRows
	};
}

function compact2(data, fcmp) {
	var numRows = 0;
	var d = data.sort(fcmp);

  let rows = [];
  
	function overlap(s1, s2) {
    if ((s1.start <= s2.start && s2.start <= s1.end) ||
      (s1.start <= s2.end && s2.end <= s1.end)) {
      return true;
    }
		return false;
	}

	for (var i = 0; i < d.length; i++) {
		var j = 0;
    let r = 0;
    // we can only ever create one new row.
    for (r = 0; r < numRows+1; r++){
      let seg = d[i];
      seg.row = r;
      if (rows[r]){
        let rseg = rows[r][rows[r].length-1];
        if (!overlap(rseg, seg)){
          break;
        }
      } else {
        break; // nothing on this row yet, so be the first
      }
    }
    rows[r] = rows[r] || [];
    rows[r].push(d[i]);
    if (numRows < r+1)
      numRows = r+1;
  }
    
	return {
		"data": d,
		"numRows": numRows
	};
}

// data = {
//   "kit1": [segments],
//   "kit2": [segments]
// }

var cat20 = d3.scaleOrdinal(d3.schemeCategory20);

function getSide(d) {
	let v = d.side || d.Side || 0;
	switch (v) {
		case "Paternal":
		case "paternal":
			return 1;
		case "Maternal":
		case "maternal":
			return 2;
		default:
			return +v % 3;
	}
}


function csvParse(text) {
	let currKit = Math.random().toString(36);

  let segments = [];
  
  /*let segments = */
  
  d3.csvParse(text, function (d, i) {
		var e = {};
    
    // myHeritage data is like:
    // DNA Match ID,Name,Match name,Chromosome,Start Location,End Location,Start RSID,End RSID,Centimorgans,SNPs,color
    // ,,,,,,,,,,
    // D-9901AC20-79C0-438F-98CA-AB11FEFE1876-D-FF58D9C4-FCEC-44F0-9654-EE143A17F70C,Simon Hailes,Beverley Porter,1,9500795,20451281,rs9662295,rs7531682,22.8,6656,red

    if (d['DNA Match ID']){
      if (d['DNA Match ID'] === 'action'){
        return {};
      }
      // like "D-9901AC20-79C0-438F-98CA-AB11FEFE1876-D-FF58D9C4-FCEC-44F0-9654-EE143A17F70C"
      let matchID = d['DNA Match ID'].split('-');
      let kitFrom = [];
      for (let i = 0; i < 6; i++){
        kitFrom.push(matchID.shift());
      }
      e.kitFrom = kitFrom.join('-');
      e.kitTo = matchID.join('-');
    } else {
      e.kitFrom = d.kit1 || d.name || d.NAME || d.Name || currKit;
      e.kitTo = d.kit2 || d.matchname || d.Match || d["MATCHNAME"] || d["Match name"] || d["Match Name"] || d["Display Name"] || "";
    }

		e.chr = (d.chr || d.Chr || d["CHROMOSOME"] || d["Chromosome"] || d["Chromosome Number"] || "0");
		e.chr = e.chr.trim() === "X" || e.chr.trim() === "x" ? 23 : + ("" + e.chr.trim()).replace(/chr/, "");
		if (e.chr < 1 || e.chr > 23) return;
    e.chr = +e.chr;

		e.start =  + (d.start || d.Start || d["START LOCATION"] || d["Start Location"] || d["Chromosome Start Point"] || "0").replace(/,/g, "");
		e.end =  + (d.end || d.End || d["END LOCATION"] || d["End Location"] || d["Chromosome End Point"] || "0").replace(/,/g, "");
    
    e.startRSID = d['Start RSID'];
    e.endRSID = d['End RSID'];
    
		e.cm =  + (d.cm || d.cM || d["CENTIMORGANS"] || d["Centimorgans"] || d["Genetic Distance"] || "0").replace(/,/g, "");
		e.side = getSide(d);
    
//    e.highlight = (e.kitTo === 'Berverly Porter');

		if (!kits[e.kitFrom]) {
			var nameFrom = (d.name1 || d.name || d.NAME || d.Name || "");
			var emailFrom = (d.email1 || "");
			kits[e.kitFrom] = {
				"kit": e.kitFrom,
				"name": nameFrom,
        outlineColour: cat20(e.kitFrom),
        kits:{},
        index: kitindex++,
        segs:{},
			};
      if (emailFrom){
				kits[e.kitFrom].email = emailFrom;
      }
		}
		if (!kits[e.kitTo]) {
			var nameTo = d.name2 || d.Match || d["MATCHNAME"] || d["Match name"] || d["Display Name"] || "";
			var emailTo = (d.email2 || "");
			var color = d.color || d.Color || d.Colour || cat20(e.kitTo);
      var opacity = 0.25;
      var always = false;
			kits[e.kitTo] = {
				"kit": e.kitTo,
				"name": nameTo,
				"color": color,
        "opacity": opacity,
        kits:{},
        index: kitindex++,
        segs:{},
			};
      if (emailTo){
        kits[e.kitTo].email = emailTo;
      }
		}
    kits[e.kitFrom].kits[e.kitTo] = true;
    
    // manually added column to help highlight or not...
    if (d.type){
      kits[e.kitTo].type = d.type;
      switch(kits[e.kitTo].type){
        case 'highlight':
          break;
        case 'ignore':
          break;
      }
    }

		e.row = 0;
		d = null;
    segments.push(e);
		return e;
	});
  
  return segments;
}


function addMatchMeta(dest, d){
  if (d['DNA Match ID']){
    let matchID = d['DNA Match ID'].split('-');
    let kitFrom = [];
    for (let i = 0; i < 6; i++){
      kitFrom.push(matchID.shift());
    }
    kitFrom = kitFrom.join('-');
    let kitTo = matchID.join('-');

    if (kitTo){
      dest.matchesMeta[kitTo] = d;
    }
  }
}

function addSegmentData(dest, d){
  // myHeritage data is like:
  // DNA Match ID,Name,Match name,Chromosome,Start Location,End Location,Start RSID,End RSID,Centimorgans,SNPs,color
  // ,,,,,,,,,,
  // D-9901AC20-79C0-438F-98CA-AB11FEFE1876-D-FF58D9C4-FCEC-44F0-9654-EE143A17F70C,Simon Hailes,Beverley Porter,1,9500795,20451281,rs9662295,rs7531682,22.8,6656,red
  let e = {};
  let currKit = Math.random().toString(36);

  
  if (d['DNA Match ID']){
    if (d['DNA Match ID'] === 'action'){
      return {};
    }
    // like "D-9901AC20-79C0-438F-98CA-AB11FEFE1876-D-FF58D9C4-FCEC-44F0-9654-EE143A17F70C"
    let matchID = d['DNA Match ID'].split('-');
    let kitFrom = [];
    for (let i = 0; i < 6; i++){
      kitFrom.push(matchID.shift());
    }
    e.kitFrom = kitFrom.join('-');
    e.kitTo = matchID.join('-');
  } else {
    e.kitFrom = d.kit1 || d.name || d.NAME || d.Name || currKit;
    e.kitTo = d.kit2 || d.matchname || d.Match || d["MATCHNAME"] || d["Match name"] || d["Match Name"] || d["Display Name"] || "";
  }

  e.chr = (d.chr || d.Chr || d["CHROMOSOME"] || d["Chromosome"] || d["Chromosome Number"] || "0");
  e.chr = e.chr.trim() === "X" || e.chr.trim() === "x" ? 23 : + ("" + e.chr.trim()).replace(/chr/, "");
  if (e.chr < 1 || e.chr > 23) return;
  e.chr = +e.chr;

  e.start =  + (d.start || d.Start || d["START LOCATION"] || d["Start Location"] || d["Chromosome Start Point"] || "0").replace(/,/g, "");
  e.end =  + (d.end || d.End || d["END LOCATION"] || d["End Location"] || d["Chromosome End Point"] || "0").replace(/,/g, "");
  
  e.startRSID = d['Start RSID'];
  e.endRSID = d['End RSID'];
  
  e.cm =  + (d.cm || d.cM || d["CENTIMORGANS"] || d["Centimorgans"] || d["Genetic Distance"] || "0").replace(/,/g, "");
  e.side = getSide(d);
  
//    e.highlight = (e.kitTo === 'Berverly Porter');

  if (!dest.kits[e.kitFrom]) {
    var nameFrom = (d.name1 || d.name || d.NAME || d.Name || "");
    var emailFrom = (d.email1 || "");
    dest.kits[e.kitFrom] = {
      "kit": e.kitFrom,
      "name": nameFrom,
      outlineColour: cat20(e.kitFrom),
      kits:{},
      index: kitindex++,
    };
    if (emailFrom){
      dest.kits[e.kitFrom].email = emailFrom;
    }
  }
  if (!dest.kits[e.kitTo]) {
    var nameTo = d.name2 || d.Match || d["MATCHNAME"] || d["Match name"] || d["Display Name"] || "";
    var emailTo = (d.email2 || "");
    var color = d.color || d.Color || d.Colour || cat20(e.kitTo);
    var opacity = 0.25;
    var always = false;
    dest.kits[e.kitTo] = {
      "kit": e.kitTo,
      "name": nameTo,
      "color": color,
      "opacity": opacity,
      kits:{},
      index: kitindex++,
    };
    if (emailTo){
      dest.kits[e.kitTo].email = emailTo;
    }
  }
  dest.kits[e.kitFrom].kits[e.kitTo] = true;
  
  // manually added column to help highlight or not...
  if (d.type){
    dest.kits[e.kitTo].type = d.type;
    switch(dest.kits[e.kitTo].type){
      case 'highlight':
        break;
      case 'ignore':
        break;
    }
  }

  e.row = 0;

  d = null;

  dest.segments.push(e);
}

//////////////////////////////////
// intended to decide what type of CSV is being parsed
function csvParseAny(text) {
	let currKit = Math.random().toString(36);

  let dataRead = {
    type: 'unknown'
  };
  
  let segments = [];
  
  /*let segments = */
  
  d3.csvParse(text, function (d, i) {
		var e = {}; // unused dummy return value
    switch(dataRead.type){
      case 'unknown':{
        let chr = (d.chr || d.Chr || d["CHROMOSOME"] || d["Chromosome"] || d["Chromosome Number"]);
        if (chr !== undefined){
          dataRead.segments = [];
          dataRead.kits = {};
          dataRead.type = 'segments';
        } else {
          if (d.Age !== undefined || d['Estimated relationship'] !== undefined){
            dataRead.type = 'matchlist';
            dataRead.matchesMeta = {};
          }
        }
      } break;
    }
    switch(dataRead.type){
      case 'unknown':{
      } break;
      case 'segments':{
        addSegmentData(dataRead, d);
      } break;
      case 'matchlist':{
        addMatchMeta(dataRead, d);
      } break;
    }
		return e;
	});
  
  //returns { type:'segments', segments[], kits:{} }
  // or { type:'matchlist', matchesMeta: {} }
  // or { type:'unknown' }
  return dataRead;
}


function rewriteData(id) {
	var csvdata = document.getElementById(id).value;
	var lines = csvdata.split("\n")

	if (lines[0] == "Comparison\tChrom.\tStart Position\tEnd Position\tGenetic Distance (cM)\tNumber of SNPs\tIdentity") {
		lines[0] = "NAME,MATCHNAME,chr,start,end,cm,snps,identity";
		for (var i=1; i<lines.length; i++) {
			lines[i] = lines[i].replace(" / ", "\t").split("\t").join(",");
		}
		document.getElementById(id).value = lines.join("\n")
	}
}


function clearData(){
	data = {};
	kits = {};
	filteredData = [];
  startRSIDs = {};
  endRSIDs = {};
}

function readCSV(text){
	var dataRead = csvParseAny(text);
  
  switch(dataRead.type){
    case 'unknown':{
    } break;
    case 'segments':{
      // we have a list of segments in dataRead.segments 
      // we have an object of kits in dataRead.kits
      // we need to merge these in to data[kitfrom]
      // we need to trigger recalculate of data['all']
      // we need to trigger recalculate of data['common'] - do we need more than one 'common'?

      // merge in to data[kitfrom]
      let kitFrom = dataRead.segments[0].kitFrom;

      // this is the existing list of segments for this kit.
      data[kitFrom] = data[kitFrom] || [];
      for (let i = 0; i < dataRead.segments.length; i++){
        // identify a unique id for this segment.
        // this should be something which will be the same next load.
        let s = dataRead.segments[i];
        let segId = s.kitFrom+'_'+s.kitTo+'_'+s.start;
        s.id = segId;
        let existingSeg = segids[segId];
        if (!existingSeg){
          // add segment
          data[kitFrom].push(s);
          segids[segId] = s;
        } else {
          // assign to existing segment
          Object.assign(existingSeg, s);
        }
      }
      
      mergeKits(dataRead);
      
      for (let i = 0; i < dataRead.segments.length; i++){
        let s = dataRead.segments[i];
        kits[s.kitTo].segs = kits[s.kitTo].segs || {};
        kits[s.kitTo].segs[s.id] = true;
      }
      
      refreshAll = true;
      refreshCommon = true;
    } break;
    case 'matchlist':{
      // copy over, merging each in.
      // so if we add notes against a match later,
      // we won't lose them.
      let metalist = Object.keys(dataRead.matchesMeta);
      for (let i = 0; i < metalist.length; i++){
        matchesMeta[metalist[i]] = matchesMeta[metalist[i]] || {};
        matchesMeta[metalist[i]] = Object.assign(matchesMeta[metalist[i]], dataRead.matchesMeta[metalist[i]]);
      }
    } break;    
  }
  
}

function mergeKits(dataRead) {
  let kitlist = Object.keys(dataRead.kits);
  for (let i = 0; i < kitlist.length; i++){
    let kit = dataRead.kits[kitlist[i]];
    if (!kits[kitlist[i]]){
      kits[kitlist[i]] = kit;
    } else {
      let kits2 = kits[kitlist[i]].kits;
      kits2 = Object.assign(kits2, kit.kits || {});
      kits[kitlist[i]] = Object.assign(kits[kitlist[i]], kit);
      kits[kitlist[i]].kits = kits2;
    }
  }
}

function recalcDataAll(){
  let kitsFrom = Object.keys(data);
  let all = [];
  for (let i = 0; i < kitsFrom.length; i++){
    if (kitsFrom[i] !== 'all' && !kitsFrom[i].startsWith('common')){
      all.push(...data[kitsFrom[i]]);
    }
  }
  data['all'] = all;
  
  setSegmentCounts();
}


function setAncestryId(value, kitid, event){
  let kit = kits[kitid];
  if (kit){
    kit.ancestryid = value;
  }
}

function setSegmentCounts(){
  let totalsegmentsel = document.getElementById('totalsegments');
  let txt = '';
  let grps = Object.keys(data);
  for (let i =0; i < grps.length; i++){
    if (!grps[i].startsWith('common') && !(grps[i] === 'all')){
      let kit = kits[grps[i]];
      txt += `<b>${kit.name}:</b> ID:${grps[i]} segments:${data[grps[i]].length}`;
      if (kit){
        txt += `<br/><span>Ancestry kit ID:</span><input title="set to the Ancestry test id to enable extra ancestry features" size=40 type="text" value="${kit.ancestryid}" id="ancestry${grps[i]}" onchange="chrombrowser.setAncestryId(event.target.value, '${grps[i]}', event);">`;
      }
    } else {
      txt += grps[i]+' segments: '+data[grps[i]].length;
    }
    txt += '<br/>';
  }
  let cnt = 0;
  for (let i =0; i < filteredData.length; i++){
    cnt += filteredData[i].segments.length;
  }
  
  txt += 'Filtered segments: '+cnt;
  txt += '<br/>';
  
  txt += 'Filtered surnames: '+Object.keys(surnames).length;
  txt += '<br/>';
  
  totalsegmentsel.innerHTML = txt;
}


function recalcDataCommon(){
  let kitsFrom = Object.keys(data);
  let kitlist = [];
  for (let i = 0; i < kitsFrom.length; i++){
    if (kitsFrom[i] !== 'all' && !kitsFrom[i].startsWith('common')){
      kitlist.push(kitsFrom[i]);
    }
    
    if (kitsFrom[i].startsWith('common')){
      delete data[kitsFrom[i]];
    }
  }
  
  for (let i = 0; i < kitlist.length; i++){
    let kit1 = kits[kitlist[i]];
    for (let j = i+1; j < kitlist.length; j++){
      let kit2 = kits[kitlist[j]];
      let name = 'common-'+kit1.name +'-'+kit2.name;
      data[name] = [];
      for (let s = 0; s < data['all'].length; s++){
        let seg = data['all'][s];
        let common = true;
        if (!kit1.kits[seg.kitTo]) common = false;
        if (!kit2.kits[seg.kitTo]) common = false;
        if (common){
          data[name].push(seg);
        }
      }
    }
  }
  setOptions();
  setSegmentCounts();
}

function recalcSurnames(){
  surnames = {};
  let mkits = Object.keys(activeKits);
  for (let i = 0; i < mkits.length; i++){
    let kit = mkits[i];
    let m = matchesMeta[kit];
    if (m && m['All ancestral surnames']) {
      let ss = m['All ancestral surnames'].split(',');
      for (let s = 0; s < ss.length; s++){
        let surname = ss[s];
        surnames[surname] = surnames[surname] || {kits:[], count:0};
        surnames[surname].kits.push(kit);
        surnames[surname].count++;
      }
    }
  }
}



function loadData() {
	data = {};
	kits = {};
	filteredData = [];
  startRSIDs = {};
  endRSIDs = {};
  
  let all = [];

	var j = 1;
	while (true) {
		var csvdata = document.getElementById('csvdata' + j);
		if (!csvdata) {
			break;
		}

		rewriteData('csvdata' + j);

		var raw = csvdata.value;
		var d = csvParse(raw);

		for (var i = 0; i < d.length; i++) {
			if (d[i].kitFrom == null) {
				continue;
			}
			data[d[i].kitFrom] = data[d[i].kitFrom] || [];
			data[d[i].kitFrom].push(d[i]);
      all.push(d[i]);
		}

		j++;
	}

  kits['all'] = {
    "kit": 'all',
    "name": 'all',
    "email": ''
  };
  kits['common'] = {
    "kit": 'common',
    "name": 'common',
    "email": ''
  };

  
  let common = [];
  let kitfroms = Object.keys(data);

  for (let i = 0; i < all.length; i++){
    let both = true;
    let seg = all[i];
    for (let j = 0; j < kitfroms.length; j++){
      if (kitfroms[j] === seg.kitTo){
        both = true;
        break;
      }
      if (!kits[kitfroms[j]]){
        both = false;
        console.error('no kit for kitfrom '+kitfroms[j]);
      } else {
        if (!kits[kitfroms[j]].kits[seg.kitTo]){
          both = false;
        }
      }
    }
    if (both){
      common.push(seg);
    }
  }
  
  data['all'] = all;
  data['common'] = common;
  
  
  getRSIDs();
  pruneRSIDs(startRSIDs);
  pruneRSIDs(endRSIDs);

	setOptions();
  
  //highlightKits();
  setHighlight();
  setSegmentCounts();
}



function loadMatchesData(){

  for (let i = 0; i < matchesData.length; i++){
    let data = matchesData[i];
    let matches = d3.csvParse(data, function (d, i) {
      return d;
    });
    
    for (let m = 0; m < matches.length; m++){
      let matchID = matches[m]['DNA Match ID'].split('-');
      let kitFrom = [];
      for (let i = 0; i < 6; i++){
        kitFrom.push(matchID.shift());
      }
      kitFrom = kitFrom.join('-');
      kitTo = matchID.join('-');
    
      if (kitTo){
        matchesMeta[kitTo] = matches[m];
      }
    }
  }
  // free memory
  matchesData = [];
}

function getRSIDs(){
  for (let i = 0; i < data['all'].length; i++){
    let d = data['all'][i];
    if (d.startRSID){
//      let s = startRSIDs[d.kitFrom] = startRSIDs[d.kitFrom] || {};
      startRSIDs[d.startRSID] = startRSIDs[d.startRSID] || [];
      startRSIDs[d.startRSID].push(d);
    }
    if (d.endRSID){
//      let e = endRSIDs[d.kitFrom] = endRSIDs[d.kitFrom] || {};
      endRSIDs[d.endRSID] = endRSIDs[d.endRSID] || [];
      endRSIDs[d.endRSID].push(d);
    }
  }
}

function pruneRSIDs(source){
  let RSIDs = Object.keys(source);
  let srcKits = Object.keys(data);
  srcKits.pop(); // remove 'all'
  
  // remove segments which don't have any other common segments
  for (let i = 0; i < RSIDs.length; i++){
    let RSID = RSIDs[i];
    if (source[RSID].length === 1){
      delete source[RSID];
    }
  }
}


function getInterestingSegs(seg){
  interestingsegs = {};
  extractRSIDs(startRSIDs, 'start');
  extractRSIDs(endRSIDs, 'end');
  console.log(interestingsegs);
  downloadInterestingKits();

}

function extractRSIDs(source, type){
  let RSIDs = Object.keys(source);
  let srcKits = Object.keys(data);
  srcKits.pop(); // remove 'all'
  
  let srcsegs = [];
  // find segments from sourcekit[0]
  for (let i = 0; i < data['all'].length; i++){
    if (data['all'][i].kitTo === srcKits[0]){
      srcsegs.push(data['all'][i]);
    }
  }
  
  for (let i = 0; i < RSIDs.length; i++){
    let RSID = RSIDs[i];
    for (let s = 0; s < source[RSID].length; s++){
      let seg = source[RSID][s];
      seg.contained = false;
      for (let k = 0; k < srcsegs.length; k++){
        let srcseg = srcsegs[k];
        if (seg.chr === srcseg.chr){
          if (seg.start > srcseg.start && seg.start < srcseg.end){
            seg.contained = true;
          }
          if (seg.end > srcseg.start && seg.end < srcseg.end){
            seg.contained = true;
          }
        }
      }
      let kit = kits[seg.kitTo];
      if (kit.highlight || kit.type === 'highlight'){
        if (!interestingsegs[seg.kitTo]){
          kits[seg.kitTo].contained = false;
          interestingsegs[seg.kitTo] = { kit: kits[seg.kitTo], segs:[],startsegs:[], endsegs:[] };
        }
        let segtype = type + 'segs';
        interestingsegs[seg.kitTo][segtype].push(RSID);
        interestingsegs[seg.kitTo].segs.push(seg);
        if (seg.contained){
          interestingsegs[seg.kitTo].kit.contained = true;
        }
      }
    }
  }
  
}

function downloadInterestingKits(){
  let kits = [];
  let keys = Object.keys(interestingsegs);
  for (let i = 0; i < keys.length; i++){
    let out = {
      kit: keys[i],
      name: interestingsegs[keys[i]].kit.name,
      contained: interestingsegs[keys[i]].kit.contained,
      segcount: interestingsegs[keys[i]].segs.length,
      startsegs: interestingsegs[keys[i]].startsegs.toString(),
      endsegs: interestingsegs[keys[i]].endsegs.toString(),
    };
    kits.push(out);
  }

  // create CSV
  let csv = d3.csvFormat(kits);
  console.log(csv);

  download(csv, "interestingMatches.csv");
}
  
function download(content, filename, contentType)
{
  if(!contentType) contentType = 'application/octet-stream';
  var a = document.createElement('a');
  var blob = new Blob([content], {'type':contentType});
  a.href = window.URL.createObjectURL(blob);
  a.download = filename;
  a.click();
}



function setOptions() {
  readConfig();
  
  // fill fromkit
  let sel = document.getElementById('fromkit');
  
  sel.innerHTML = '';
  
  let keys = Object.keys(data);
  
  if (!config.fromkit && keys.length){
    config.fromkit = keys[keys.length-1];
  }
  
  for (let i = 0; i < keys.length; i++){
    let name = keys[i];
    let value = keys[i];
    if (kits[keys[i]] && kits[keys[i]].name){
      name = kits[keys[i]].name;
    }
    
    let option = document.createElement('option');
    option.value = value;
    option.innerHTML = name;
    sel.appendChild(option);
  }
}

function filterData(segments, includekits, excludekits, minCm, maxCm) {
  let org = filteredData;
	filteredData = [];
  
	if (segments.length == 0) {
		return;
	}

	var d = segments;

  let filteredsegs = [];
  
  for (let i = 0; i < d.length; i++){
    let e = d[i];
  
    // always include segs in the include list, regardless of min/max cm
    if (includekits.length > 0) {
      if (includekits.includes(e.kitTo)){
        filteredsegs.push(e);
        if (segdivs[e.id]) segdivs[e.id].style.display = 'none';
        continue;
      }
    }
    if (e.cm < minCm){
      if (segdivs[e.id]) segdivs[e.id].style.display = 'none';
      continue;
    }
    if (e.cm > maxCm){
      if (segdivs[e.id]) segdivs[e.id].style.display = 'none';
      continue;
    }

    if (excludekits.length > 0) {
      if (excludekits.includes(e.kitTo)){
        if (segdivs[e.id]) segdivs[e.id].style.display = 'none';
        continue;
      }
    }
    filteredsegs.push(e);
    if (segdivs[e.id]) segdivs[e.id].style.display = 'block';
  }

	for (var i = 0; i <= 23; i++) {
    for (var j = 0; j < 3; j++) {
      var o = {
        "chr": i,
        "side": j,
        "segments": [],
        "div": (org && org[3*i + j]) ? org[3*i + j].div: null,
      };
      filteredData.push(o);
    }
	}

	for (var i = 0; i < filteredsegs.length; i++) {
		// filteredData[d[i].chr] = filteredData[d[i].chr] || {"segments": []};
		filteredData[3*filteredsegs[i].chr + filteredsegs[i].side].segments.push(filteredsegs[i]);
	}

	//filteredData = filteredData.filter(e => e.segments.length > 0);
}

function sortData(data, viewType) {
	var o = {};

	for (var i = 0; i < data.length; i++) {
		switch (viewType) {
		case "compact":
			o = compact2(data[i].segments, compareSegment);
			break;
		case "compactreverse":
			o = compact2(data[i].segments, compareSegmentReverse);
			break;
		case "kitsize":
			o = sortByKitSize(data[i].segments);
			break;
		case "segment":
			o = sortBySegment(data[i].segments, compareSegment);
			break;
		case "segmentreverse":
			o = sortBySegment(data[i].segments, compareSegmentReverse);
			break;
		}

		data[i].segments = o.data;
		data[i].numRows = o.numRows;
	}

	return data;
}


function getWidth() {
  return Math.max(
    document.body.scrollWidth,
    document.documentElement.scrollWidth,
    document.body.offsetWidth,
    document.documentElement.offsetWidth,
    document.documentElement.clientWidth
  );
}


function ancestryMemberSearch(name){
  var a = document.createElement('a');
  a.href = `https://${config.ancestryurl}/community/membersearch?q=${name.split(' ').join('+')}&page=1`;
  a.target = '_blank';
  a.click();
}


function mouseover2(ev) {
  let name = "";
  let fromName = "";
  let str = '';
  
  let d;
  for (let i = 0; i < data['all'].length; i++){
    if (data['all'][i].id === event.target.id){
      d = data['all'][i];
      break;
    }
  }
  
  if (!d){
    console.log('seg not found');
    return;
  }
  
  if (kits[d.kitTo].name !== d.kitTo) {
    name = kits[d.kitTo].name;
  }
  if (kits[d.kitFrom].name !== d.kitFrom) {
    fromName = kits[d.kitFrom].name;
  }
  tooltipDiv.style.display = 'block';

  str += `<b>${name}:${fromName}</b> ${d.cm.toFixed(1)}cM<br/>`;
  
  if (matchesMeta[d.kitTo] && matchesMeta[d.kitTo]['Number of individuals in the tree']){
    let url = matchesMeta[d.kitTo]['View tree'];
    str += `<a href="${url}" target="_blank">Tree of ${matchesMeta[d.kitTo]['Number of individuals in the tree']}</a><br/>`;
  }  
  
  str += `Chr <b>${d.chr}:</b>`+
    d.start.toLocaleString() + " to " + d.end.toLocaleString() + "<br>";
    
  if (d.startRSID){
    str += 'RSID: '+ d.startRSID + " to " + d.endRSID + "<br>";
  }
    
  if (name) name = ' name '+name;
  if (fromName) fromName = ' name '+fromName;
  str += "kitTo " + d.kitTo + name + "<br/>"+
    "kitFrom " + d.kitFrom + fromName + "<br/>";

  if (kits[d.kitTo].notes){
    str += '<br/>'+kits[d.kitTo].notes;
  }
    
  tooltipDiv.innerHTML = str;
  
  let clickCoordsX = (ev.pageX + 40);
  let clickCoordsY = (ev.pageY - 28);

  let menuWidth = tooltipDiv.offsetWidth + 4;
  let menuHeight = tooltipDiv.offsetHeight + 4;

  let windowWidth = window.innerWidth;
  let windowHeight = window.innerHeight;

  if ( (windowWidth - clickCoordsX) < menuWidth ) {
    tooltipDiv.style.left = windowWidth - menuWidth + "px";
  } else {
    tooltipDiv.style.left = clickCoordsX + "px";
  }

  if ( (windowHeight - clickCoordsY) < menuHeight ) {
    tooltipDiv.style.top = windowHeight - menuHeight + "px";
  } else {
    tooltipDiv.style.top = clickCoordsY + "px";
  }
  
  console.log(d.start + " to " + d.end + " kit [" + d.kitTo + "] name " + d.name);
}

function mouseout() {
  tooltipDiv.style.display = 'none';
}

function clickSeg(ev) {
  if (menuState){
    toggleMenuOff();
    return;
  }
}

function dblClickSeg(ev){
  let kit = getKitFromSeg(ev.target.id);
  if (!kit) return;

  highlightAllMatchingKit(kit, true);
}

function getKitFromSeg(segid){
  if (!segids[segid]) return;
  return segids[segid].kitTo;
}

/*function highlightKits(){
  let keys = Object.keys(kits);
  for (let i = 0; i < keys.length; i++){
    if (kits[keys[i]].type === 'highlight'){
      highlightAllMatchingKit(keys[i], true);
    }
  }
  for (let i = 0; i < keys.length; i++){
    if (kits[keys[i]].type === 'ignore'){
      highlightAllMatchingKit(keys[i], false);
    }
  }
}*/

function highlightAllMatchingKit(kit, enable){
	var segments = data['all'] || [];

  let kitsegs = {};
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    if (seg.kitTo === kit){
      kitsegs[seg.chr] = kitsegs[seg.chr] || [];
      kitsegs[seg.chr].push(seg);
    }
  }
  
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    if (kitsegs[seg.chr]){
      for (let i = 0; i < kitsegs[seg.chr].length; i++){
        let ks = kitsegs[seg.chr][i];
        if ((seg.start < ks.start && seg.end > ks.start) ||
            (seg.start < ks.end && seg.end > ks.end) ||
            (seg.start >= ks.start && seg.end <= ks.end)){
          if (enable){
            seg.mark = "always";
          } else {
            seg.mark = "never";
          }
          segDivHighlight(seg.id, enable);
        }
      }
    }
  }

}

function highlightAllMatchingSeg(segid, enable){
	var segments = data['all'] || [];

  let kitsegs = {};
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    if (seg.id === segid){
      kitsegs[seg.chr] = kitsegs[seg.chr] || [];
      kitsegs[seg.chr].push(seg);
    }
  }
  
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    if (kitsegs[seg.chr]){
      for (let i = 0; i < kitsegs[seg.chr].length; i++){
        let ks = kitsegs[seg.chr][i];
        if ((seg.start < ks.start && seg.end > ks.start) ||
            (seg.start < ks.end && seg.end > ks.end) ||
            (seg.start >= ks.start && seg.end <= ks.end)){
          if (enable){
            seg.mark = "always";
          } else {
            seg.mark = "never";
          }
          segDivHighlight(seg.id, enable);
        }
      }
    }
  }
}



// pass '' or 'always' or 'never'
function highlightAll(enable){
	var segments = data['all'] || [];

  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    if (enable){
      seg.mark = "always";
    } else {
      seg.mark = "never";
    }
    segDivHighlight(seg.id, enable);
  }
}

// highlight segs from one kit.
function highlightKit(kitid, enable){
  let kit = kits[kitid];
  if (kit) kit.higlight = enable;
  var segments = data['all'] || [];
  // highlight segs from kit highlight only.
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    if (seg.kitTo === kitid){
      seg.mark = enable?'always':'never';
      segDivHighlight(seg.id, enable);
    }
  }
}


// highlight multiple kits - kitids = [kit1, kit2, ...]
function highlightKits(kitids, enable){
  for (let i = 0; i < kitids.length; i++){
    let kit = kits[kitids[i]];
    if (kit) kit.higlight = enable;
  }
  
  var segments = data['all'] || [];
  // highlight segs from kit highlight only.
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    if (kitids.includes(seg.kitTo)){
      seg.mark = enable?'always':'never';
      segDivHighlight(seg.id, enable);
    }
  }
}

function segDivHighlight(id, enable){
  let segdiv = segdivs[id];
  if (segdiv){
    let opacity = enable? 1.0:0.5;
    if ((+segdiv.style.opacity) != opacity){
      segdiv.style.opacity = opacity;
    }
    /* hmm.. can't do this here because the row also changes.
    if (config.hideuncoloured === 'coloured'){
      if(enable){
        
      }
    }*/
  }
}

// highlight kits which have surname
function highlightSurname(surname, enable){
  var segments = data['all'] || [];
  // highlight segs from kit highlight only.
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    let kitid = seg.kitTo;
    let meta = matchesMeta[kitid];
    if (meta && meta['All ancestral surnames']){
      let ss = meta['All ancestral surnames'].split(',');
      if (ss.includes(surname)){
        seg.mark = enable?'always':'never';
        kits[kitid].higlight = enable;
        segDivHighlight(seg.id, enable);
      }
    }
  }
}


function setHighlight(){
	var segments = data['all'] || [];
  // highlight segs from kit highlight only.
  for (let s = 0; s < segments.length; s++){
    let seg = segments[s];
    let segdiv = segdivs[seg.id];
    let highlight = true; //kits[seg.kitTo].highlight; // default to kit highlight
    if (seg.mark === 'always') highlight = true;
    if (seg.mark === 'never') highlight = false;
    let opacity = highlight? 1.0:0.5;
    if (segdiv){
      if ((+segdiv.style.opacity) != opacity){
        segdiv.style.opacity = opacity;
      }
      if (seg.marked || kits[seg.kitTo].marked){
        segdiv.classList.add('marked');
      } else {
        segdiv.classList.remove('marked');
      }
    }
    //kits[seg.kitTo].opacity = opacity;
  }
  
  setSegmentCounts();
  
}


function surnameList(){
  let html = '';
  let ss = Object.keys(surnames);
  
  ss.sort((a, b)=>{
    if (surnames[a].count < surnames[b].count) return 1;
    if (surnames[a].count > surnames[b].count) return -1;
    return 0;
  });
  
  for (let i = 0; i < ss.length; i++){
    html += `<span class="clickable" title="click to higlight all kits with this surname" onclick="chrombrowser.highlightSurname('${ss[i]}', true);"><u>${ss[i]}</u></span>`;
    html += `(${surnames[ss[i]].count})`;
    html += '<br/>';
  }
  return html;
}


function addSegments(div, chrom, chromwidth) {

  readConfig();

	var sc = (len)=>{
    let newlen = (len/chrlen[chrom.chr])*chromwidth;
    return newlen;
  };

  for (let s = 0; s < chrom.segments.length; s++){
    let d = chrom.segments[s];
    let newdiv = segdivs[d.id];
    let isnew = false;
    if (!newdiv){
      newdiv = document.createElement('DIV');
      newdiv.id = d.id;
      segdivs[d.id] = newdiv;
      isnew = true;
    }
    newdiv.style.width = (sc(d.end) - sc(d.start)) + 'px';
    newdiv.style.height = config.segmentHeight + 'px'
    newdiv.style.top = (1 + d.row * (config.segmentHeight + 1)) + 'px';
    newdiv.style.left = sc(d.start) + 'px';

    let highlight = true; //kits[d.kitTo].highlight; // default to kit highlight
    if (d.mark === 'always') highlight = true;
    if (d.mark === 'never') highlight = false;
    let opacity = highlight? 1.0:0.5;
    
    newdiv.style.opacity = opacity;
    newdiv.style.display = 'block';
    
    if (matchesMeta[d.kitTo] && matchesMeta[d.kitTo]['Number of individuals in the tree']){
      newdiv.classList.add('hastree');
      newdiv.dataset['treecount'] = `(${matchesMeta[d.kitTo]['Number of individuals in the tree']})`;
    } else {
      newdiv.classList.add('notree');
    }
    
    activeKits[d.kitTo] = true;
    
    if (isnew) {
      
      newdiv.style.outline =  '3px solid '+kits[d.kitFrom].outlineColour;
      if (!kits[d.kitTo].color) kits[d.kitTo].color = cat20(d.kitTo);
      newdiv.style.backgroundColor = kits[d.kitTo].color;
      
      newdiv.classList.add('segment');

      newdiv.addEventListener('mouseover', mouseover2);//(event) => {mouseover(event, d);});
      newdiv.addEventListener('mouseout', mouseout);
      
      let name = kits[d.kitTo].name || d.kitTo;
      let prefix = (kits[d.kitTo].tag || '') + (d.tag || '');
      switch (config.nametype){
        case 'name':
          break;
        case 'kit':
          name = d.kitTo;
          break;
        case 'index':
          name = kits[d.kitTo].index;
          break;
      }
      newdiv.innerHTML = prefix+name;
      
    }
    div.append(newdiv);
  }
}



function getChrBoxWidth(chr, chrsize, screenwidth) {
  let localwidth = width;
  if (screenwidth){
    localwidth = screenwidth;
  }
	if (chrsize === 'proportional') {
		return localwidth * chrlen[chr] / chrlen[1];
	}

	return localwidth;
}

async function updateCm() {
	await updateAll();
}

async function updateAll() {
  await promiseStartWait('UpdateAll');

  readConfig();
	updateData();
  await updateDivDisplay();
}


function readConfig(){
	config.viewtype = document.getElementById("viewtype").value;
	config.chrview = +document.getElementById("chrview").value;
	config.segmentHeight = +document.getElementById("segmentHeight").value;
	config.chrsize = document.getElementById("chrsize").value;
  config.screenwidth = +document.getElementById("screenwidth").value;
  config.hideuncoloured = document.getElementById("hideuncoloured").value;
	config.fromkit = document.getElementById("fromkit").value;
  config.nametype =  document.getElementById("nametype").value;
	config.includekits = document.getElementById("includekits").value.split('\n').filter(e => e.length > 0);
	config.excludekits = document.getElementById("excludekits").value.split('\n').filter(e => e.length > 0);
	config.minCm = document.getElementById("minCm").value || 5;
	config.maxCm = document.getElementById("maxCm").value || 1000;
  
  config.ancestryurl = document.getElementById("ancestryurl").value || 'www.ancestry.co.uk';
}

function setConfig(){
	document.getElementById("viewtype").value = config.viewtype;
	document.getElementById("chrview").value = config.chrview;
	document.getElementById("segmentHeight").value = config.segmentHeight;
  document.getElementById("chrsize").value = config.chrsize;
  document.getElementById("screenwidth").value = config.screenwidth;
  document.getElementById("hideuncoloured").value = config.hideuncoloured;
	document.getElementById("fromkit").value = config.fromkit;
  document.getElementById("nametype").value = config.nametype;
	document.getElementById("includekits").value = config.includekits.join('\n');
  document.getElementById("excludekits").value = config.excludekits.join('\n');
	document.getElementById("minCm").value = config.minCm;
	document.getElementById("maxCm").value = config.maxCm;
  
  document.getElementById("ancestryurl").value = config.ancestryurl  || 'www.ancestry.co.uk';
}


async function updateDivDisplay() {
  await promiseStartWait('updating');

  readConfig();
	var rootDiv = document.getElementById("divchrbrowser");
  rootDiv.innerHTML = '';
  
  var scrollDiv = document.getElementById("chrbrowsercontainer");
  
	let segments = data[config.fromkit] || [];
  
  activeKits = {};
  
  await promiseStartWait('hide segments');
  let segs = data['all'] || [];
  // hide all segments which have divs - we may filter them out and they would remain.
  for (let i = 0; i < segs.length; i++){
    if (segdivs[segs[i].id]){
      segdivs[segs[i].id].style.display = 'none';
    }
  }

  await promiseStartWait('hide chromosomes');
  // hide existing chromosome boxes
  if (filteredByChr){
    for (let i = 0; i < filteredByChr.length; i++){
      let chrom = filteredByChr[i];
      if (chrom.div){
        chrom.div.style.display = 'none';
        chrom.div.innerHTML = '';
      }
    }
  }
  
  await promiseStartWait('filter data');
	filteredByChr = filteredData;
	if (config.chrview != 0 ) {
		filteredByChr = filteredData.filter(e => e.chr == config.chrview);
	}
  
  if (config.hideuncoloured === 'coloured'){
    await promiseStartWait('hide not highlighted');
    for (let i = 0; i < filteredByChr.length; i++){
      let chrom = filteredByChr[i];
      let newsegs = [];
      for (let s = 0; s < chrom.segments.length; s++){
        let seg = chrom.segments[s];
        let highlight = true; //kits[seg.kitTo].highlight; // default to kit highlight
        if (seg.mark === 'always') highlight = true;
        if (seg.mark === 'never') highlight = false;

        if (highlight){
          newsegs.push(seg);
        }
      }
      chrom.segments = newsegs;
    }
  }
  
  await promiseStartWait('sort data');
  let now = Date.now();
	filteredByChr = sortData(filteredByChr, config.viewtype);
  let then = Date.now();
  console.log('sort took '+((then-now)/1000));

	// Create chromosomes
  let y = 0;
  for (let i = 0; i < filteredByChr.length; i++){
    let chrom = filteredByChr[i];
    if (chrom.segments.length){
      let newdiv = chrom.div;
      let isnew = false;
      if (!newdiv){
        newdiv = document.createElement('DIV');
        chrom.div = newdiv;
        newdiv.classList.add('chrom');
        isnew = true;
      }
      let chromwidth = getChrBoxWidth(chrom.chr, config.chrsize, config.screenwidth);

      newdiv.id = `chrdiv${chrom.chr}_${chrom.side}`;
      newdiv.style.width = chromwidth + 'px';
      newdiv.style.height = 1 + chrom.numRows * (config.segmentHeight + 1) + 'px'
      newdiv.style.top = y + 'px';
      newdiv.style.left = 20 + 'px';
      //newdiv.style.position = 'absolute';
      newdiv.addEventListener('click', contextMenu);
//      newdiv.addEventListener('dblclick', dblClickSeg);
//      newdiv.addEventListener('contextmenu', contextMenu);

      // only display if not filtered by chromosome
      if (config.chrview && (chrom.chr != config.chrview)){
        newdiv.style.display = 'none';
      } else {
        y += 1 + chrom.numRows * (config.segmentHeight + 1);
        newdiv.style.display = 'block';
      }

      // the div is always empty when it get here, so
      // add the label.
      let label = document.createElement('DIV');
      label.style.position = 'absolute';
      label.style.left = -20 + 'px';
      label.innerHTML = (chrom.chr == 23) ? 'X' : `${chrom.chr}`
      newdiv.append(label);
      
      rootDiv.append(newdiv);
      
      // create segments 
      addSegments(newdiv, chrom, getChrBoxWidth(chrom.chr, config.chrsize, config.screenwidth ));
    }
  }
  
  await promiseStartWait('recalc surnames');
  recalcSurnames();
  await promiseStartWait('set highlights');
  setHighlight();
}

async function updateViewType(){
  readConfig();
  await promiseStartWait('updating view type');
  let now = Date.now();
	filteredByChr = sortData(filteredByChr, config.viewtype);
  let then = Date.now();
  console.log('sort took '+((then-now)/1000));
  await promiseStartWait('updating Positions');
  updatePosn();
}

async function updateHidden(){
  await promiseStartWait('updating hidden');
  updateData();
  await updateDivDisplay();
}

function updatePosn(){
  readConfig();

  let y = 0;
  for (let i = 0; i < filteredByChr.length; i++){
    let chrom = filteredByChr[i];
    if (chrom.div){
      let chromwidth = getChrBoxWidth(chrom.chr, config.chrsize, config.screenwidth);
      var sc = (len)=>{
        let newlen = (len/chrlen[chrom.chr])*chromwidth;
        return newlen;
      };
      let height = 1 + chrom.numRows * (config.segmentHeight + 1) + 'px'
      let top = y + 'px';
      y += 1 + chrom.numRows * (config.segmentHeight + 1);

      if (chrom.div.style.width !== chromwidth + 'px') chrom.div.style.width = chromwidth + 'px';
      if (chrom.div.style.height !== height) chrom.div.style.height = height;
      if (chrom.div.style.top !== top) chrom.div.style.top = top;
      for (let s = 0; s < chrom.segments.length; s++){
        let d = chrom.segments[s];
        if (segdivs[d.id]){
          let div = segdivs[d.id];
          let width = (sc(d.end) - sc(d.start)) + 'px';
          let height = config.segmentHeight + 'px'
          let top = (1 + d.row * (config.segmentHeight + 1)) + 'px';
          let left = sc(d.start) + 'px';
          if (div.style.top !== top) div.style.top = top;
          if (div.style.height !== height) div.style.height = height;
          if (div.style.width !== width) div.style.width = width;
          if (div.style.left !== left) div.style.left = left;
          let name = kits[d.kitTo].name;
          let prefix = (kits[d.kitTo].tag || '') + (d.tag || '');
          switch (config.nametype){
            case 'name':
              break;
            case 'kit':
              name = d.kitTo;
              break;
            case 'index':
              name = kits[d.kitTo].index;
              break;
          }
          if (div.innerHTML !== prefix+name){
            div.innerHTML = prefix+name;
          }
        }
      }
    }
  }
    
}



function updateData() {
  readConfig();
	var segments = data[config.fromkit] || [];
	filterData(segments, config.includekits, config.excludekits, config.minCm, config.maxCm);
}

function dragOverHandler(ev) {
	// Prevent default behavior (Prevent file from being opened)
	ev.preventDefault();
}

async function loadJson(fileitem, ext) {
	var file = fileitem;
  return new Promise((resolve, reject)=>{
    var reader = new FileReader();
    reader.onloadend = function () {
      let data = reader.result;
      if (ext === 'gz'){
        decompress(data).then((text)=>{
          let json = JSON.parse(text);
          processJson(json);
          //setOptions();
          setHighlight();
          resolve();
        });
      } else {
        let json = JSON.parse(data);
        processJson(json);
        //setOptions();
        setHighlight();
        resolve();
      }
    }
    reader.onerror = function (err) {
      reject(err);
    }
    if (ext === 'gz'){
      reader.readAsArrayBuffer(file);
    } else {
      reader.readAsText(file);
    }
  });
}

//////////////////////////////////////////////////////////////
// deal with .gz json files
// compress string to arraybuffer
function compress(string) {
  const byteArray = new TextEncoder().encode(string);
  const cs = new CompressionStream('gzip');
  const writer = cs.writable.getWriter();
  writer.write(byteArray);
  writer.close();
  return new Response(cs.readable).arrayBuffer();
}

// decompress arraybuffer to string
function decompress(byteArray) {
  const cs = new DecompressionStream('gzip');
  const writer = cs.writable.getWriter();
  writer.write(byteArray);
  writer.close();
  return new Response(cs.readable).arrayBuffer().then(function (arrayBuffer) {
    return new TextDecoder().decode(arrayBuffer);
  });
}
//////////////////////////////////////////////////////////////

function setFilenames(filenamesarray){
  let txt = '';
  for (let i = 0; i < filenamesarray.length; i++){
    txt += filenamesarray[i];
    txt += '\n';
  }
 
  let curr = document.getElementById('filenames').innerText;
  if (curr) curr += '\n';
  document.getElementById('filenames').innerText = curr + txt;
}
function getFilenames(){
  let txt = document.getElementById('filenames').innerText;
  return txt;
}



function processJson(downloaddata){
  matchesMeta = downloaddata.matchesMeta || {};
  kits = downloaddata.kits;
  
  data = {};
  segids = {};
  
  document.getElementById('filenames').innerText = downloaddata.notes;
  
  let all = [];

  readConfig();
  config = Object.assign(config, downloaddata.config || {});
  // ensure the readConfig in setOptions does not overwrite us...
  setConfig();
  
  
  let sources = Object.keys(downloaddata.sources);
  for (let i = 0; i < sources.length; i++){
    data[sources[i]] = downloaddata.sources[sources[i]];
    for (let j = 0; j < data[sources[i]].length; j++){
      let seg = data[sources[i]][j];
      all.push(seg);
      segids[seg.id] = seg;
    }
  }

  // clears segs for rebuild;
  let ks = Object.keys(kits);
  for (let i = 0; i < ks.length; i++){
    kits[ks[i]].segs = {};
  }
  
  let common = [];
  let kitfroms = Object.keys(data);

  for (let i = 0; i < all.length; i++){
    let both = true;
    let seg = all[i];
    for (let j = 0; j < kitfroms.length; j++){
      if (kitfroms[j] === seg.kitTo){
        both = true;
        break;
      }
      
      if (!kits[kitfroms[j]]){
        both = false;
        console.error('no kit for kitfrom '+kitfroms[j]);
      } else {
        if (!kits[kitfroms[j]].kits[seg.kitTo]){
          both = false;
        }
      }
    }
    if (both){
      common.push(seg);
    }
    
    kits[seg.kitTo].segs[seg.id] = true;
  }

  data['all'] = all;
  data['common'] = common;
  
  getRSIDs();
  pruneRSIDs(startRSIDs);
  pruneRSIDs(endRSIDs);
  

  // needs data[]
  setOptions();
  // needs options set to set fromkit....
  setConfig();
  
}


// returns textual content of a file
function loadFileText(fileitem) {
	var file = fileitem;
  return new Promise((resolve)=>{
    var reader = new FileReader();
    reader.onloadend = ()=>{
      resolve(reader.result);
    };
    reader.onerror = ()=>{
      reject(arguments);
    };
    reader.readAsText(file);
  });
}


async function dropHandler(ev) {
	// Prevent default behavior (Prevent file from being opened)
	ev.preventDefault();

	var tasks = [];
  
  let filenames = [];
  
  // note: ev may not survive await?
  let items = ev.dataTransfer.items;
  
  // note: items and content of items does not survive await?
  // so we must have a loop which starts all the asyn we need to do, then 
  // wait of for all of them to complete before proceeding.

	if (items) {
    let files = [];
    let tasks = [];
		for (var i = 0; i < items.length; i++) {
			// If dropped items aren't files, reject them
			if (items[i].kind === 'file') {
        let item = items[i];
        let file = item.getAsFile();
        let f = {
          file: file,
          filename: file.name,
          ext: file.name.toLowerCase().split('.').pop(),
        };
        files.push(f);
        if (f.ext === 'gz'){
          let task = new Promise((resolve, reject) => {
            item.getAsFileSystemHandle()
              .then((handle)=>{
                f.handle = handle;
                resolve();
              });
					});
          tasks.push(task); 
        }
      }
    }

    // we've done all synchronous processing
    // Pass event to removeDragData for cleanup
    removeDragData(ev)

    await promiseStartWait('Dropping file');

    // await any async we created to get gz handle
    await Promise.all(tasks);
    
    
    // we should now have all the things we need,
    // and they should survive await.
		for (var i = 0; i < files.length; i++) {
      let f = files[i].file;
      let ext = files[i].ext;
      let fname = files[i].filename;
      if (ext === 'gz'){
        // global filename used for save
        filename = fname;
        gzHandle = files[i].handle;
        let x = await setExistingFile(fname);
        startWait('Loading '+filename);
        await loadJson(f, ext);
        document.getElementById('filename').innerHTML = "save <b>"+filename+"</b>";
      } else {
        startWait('Loading '+fname);
        filenames.push(fname);
        let text = await loadFileText(f);
        await readCSV(text);
      }
		}
	}

  if (refreshAll){
    recalcDataAll();
    refreshAll = false;
  }
  if (refreshCommon){
    recalcDataCommon();
    refreshCommon = false;
  }

  setFilenames(filenames);
  
  await updateAll();
  await promiseEndWait();
}


function removeDragData(ev) {
	if (ev.dataTransfer.items) {
		// Use DataTransferItemList interface to remove the drag data
		ev.dataTransfer.items.clear();
	} else {
		// Use DataTransfer interface to remove the drag data
		ev.dataTransfer.clearData();
	}
}

function showdiv(ev, id) {
  
  if (ev){
    ev.stopPropagation();
  }

  readConfig();
  
	var currentStyle = d3.select("#" + id).attr("style");
	if (currentStyle === 'display: block;') {
		d3.select("#" + id).attr("style", "display: none;");
	} else {
		d3.select("#data").attr("style", "display: none;");
		d3.select("#filters").attr("style", "display: none;");
		d3.select("#display").attr("style", "display: none;");
		d3.select("#surnameslist").attr("style", "display: none;");
		d3.select("#about").attr("style", "display: none;");
		if (id !== 'none') {
      if (id === 'surnameslist'){
        let surnamesel = document.getElementById('surnamelist');
        let html = surnameList();
        if (html){
          surnamesel.innerHTML = html;
        } else {
          surnamesel.innerHTML = 'Add a Matches List file';
        }
      }
			d3.select("#" + id).attr("style", "display: block;");
		}
	}
}

async function getRecentFiles(){
  let recents = await get('recentfiles');
  if (recents){
    recentFiles = JSON.parse(recents);
    while (recentFiles.files.length > 10){
      recentFiles.files.pop();
    }
  } else {
    recentFiles = {files:[]};
  }
  updateRecentsButtons();
}

function updateRecentsButtons(){
  let recentsdiv = document.getElementById("recentfiles");
  recentsdiv.innerHTML = '';
  let html = '';
  for (let i = 0; i < recentFiles.files.length; i++){
    html += `<button id="recent${i}" onclick="chrombrowser.wrapFn(async ()=>{await chrombrowser.getExistingFile('${recentFiles.files[i]}');});">Load ${recentFiles.files[i]}</button><br/>`;
  }
  recentsdiv.innerHTML = html;
}

async function addRecentFile(file){
  recentFiles = recentFiles || {files:[]};
  
  for (let i = recentFiles.files.length-1; i >= 0; i--){
    if (recentFiles.files[i] === file){
      recentFiles.files.splice(i, 1);
    }
  }
  
  recentFiles.files.unshift(file);
  while (recentFiles.files.length > 10){
    recentFiles.files.pop();
  }
  let recents = JSON.stringify(recentFiles);
  await set('recentfiles', recents);
  updateRecentsButtons();
}

async function getExistingFileName(){
  await getRecentFiles();
}

async function getExistingFile(file){
  file = file || recentFiles.files[0];
  if (!file) return;
  await addRecentFile(file);
  updateRecentsButtons();
  let fileHandleOrUndefined = await get(file);
  if (fileHandleOrUndefined) {
    let status = await fileHandleOrUndefined.requestPermission({ mode : "readwrite" });
    if (status){
      gzHandle = fileHandleOrUndefined;
      let f = await gzHandle.getFile();
      filename = f.name;
      let ext = f.name.toLowerCase().split('.').pop();
      startWait('Loading '+filename);
      await loadJson(f, ext);
      document.getElementById('filename').innerHTML = "save <b>"+filename+"</b>";

      await updateAll();
    }
  }
}

async function setExistingFile(file){
  await addRecentFile(file)
  await set(file, gzHandle);    
}

async function pageLoad() {
  await getExistingFileName();
	showdiv(null, 'data');
  
	var rootDiv = document.getElementById("divchrbrowser");
  var scrollDiv = document.getElementById("chrbrowsercontainer");
  dragFeature(rootDiv, scrollDiv);
}

function keydown(ev){
  switch(ev.key){
    case 'Escape':
      showdiv(null, 'none');
      toggleMenuOff();
      break;
    case 'Enter':
      ev.preventDefault();
      break;
  }
}

function clickout(event) {
  showdiv(event, 'none');
  toggleMenuOff();
}



let resizeTimer;
window.onresize = ()=>{
  if (!resizeTimer){
    resizeTimer = setTimeout(()=>{
      resizeTimer = null;
      refresh();
    }, 200);
  }
}


////////////////////////////////////////////////////
// searching Ancestry matches:
// searchlocation=London,%20London,%20England
// searchsurname
// searchmatchname

// not used for the moment.... since we don't necessarily have surnames
function searchAncestryMatchesSurname(kit, name){
  let ancestrymatchid = kits[kit].ancestryid;
  if (!ancestrymatchid) return;
  let url = `https://${config.ancestryurl}/discoveryui-matches/list/${ancestrymatchid}?searchsurname=${name}`;
  if (url){
    var a = document.createElement('a');
    a.href = url;
    a.target = '_Blank';
    a.click();
  }
}

function searchAncestryMatchName(kit, name){
  let ancestrymatchid = kits[kit].ancestryid;
  if (!ancestrymatchid) return;
  let url = `https://${config.ancestryurl}/discoveryui-matches/list/${ancestrymatchid}?searchmatchname=${name}`;
  if (url){
    var a = document.createElement('a');
    a.href = url;
    a.target = '_Blank';
    a.click();
  }
}

function getAncestrySurnameUrl(kit, name){
  let ancestrymatchid = kits[kit].ancestryid;
  if (!ancestrymatchid) return '';
  let url = `https://${config.ancestryurl}/discoveryui-matches/list/${ancestrymatchid}?searchsurname=${name}`;
  return url;
}

function getAncestryCompareUrl(kit1, kit2){
  let ancestrymatchid1 = kits[kit1].ancestryid;
  let ancestrymatchid2 = kits[kit2].ancestryid;
  if (!ancestrymatchid1 || !ancestrymatchid2) return '';
  let url = `https://${config.ancestryurl}/discoveryui-matches/compare/${ancestrymatchid1}/with/${ancestrymatchid2}`;
  return url;
}


////////////////////////////////////////////////////

////////////////////////////////////////////////////
// Make the DIV element draggable:

function dragElement(elmnt) {
  var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
  if (document.getElementById(elmnt.id + "header")) {
    // if present, the header is where you move the DIV from:
    document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
  } else {
    // otherwise, move the DIV from anywhere inside the DIV:
    elmnt.onmousedown = dragMouseDown;
  }

  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    // get the mouse cursor position at startup:
    pos3 = e.clientX;
    pos4 = e.clientY;
    document.onmouseup = closeDragElement;
    // call a function whenever the cursor moves:
    document.onmousemove = elementDrag;
  }

  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault();
    // calculate the new cursor position:
    pos1 = pos3 - e.clientX;
    pos2 = pos4 - e.clientY;
    pos3 = e.clientX;
    pos4 = e.clientY;
    // set the element's new position:
    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
  }

  function closeDragElement() {
    // stop moving when mouse button is released:
    document.onmouseup = null;
    document.onmousemove = null;
  }
}
////////////////////////////////////////////////////


let isDirty = true;
window.onbeforeunload = function() {
  if (isDirty) {
    return 'There is unsaved data.';
  }
  return undefined;
}


let dragFeature = function(el, scrollel){

  let handler = {
    el: el,
    ele: scrollel, 
    pos: { top: 0, left: 0, x: 0, y: 0 },
    mouseDownHandler: (e)=>{
      console.log('mdn ');
      handler.pos = {
          // The current scroll
          left: handler.ele.scrollLeft,
          top: handler.ele.scrollTop,
          // Get the current mouse position
          x: e.clientX,
          y: e.clientY,
      };

      document.addEventListener('mousemove', handler.mouseMoveHandler);
      document.addEventListener('mouseup', handler.mouseUpHandler);
      // Change the cursor and prevent user from selecting the text
      handler.ele.style.cursor = 'grabbing';
      handler.ele.style.userSelect = 'none';
    },
    mouseMoveHandler: (e)=>{
      // How far the mouse has been moved
      const dx = e.clientX - handler.pos.x;
      const dy = e.clientY - handler.pos.y;
      console.log('mmove '+dy);

      // Scroll the element
      handler.ele.scrollTop = handler.pos.top - dy;
      handler.ele.scrollLeft = handler.pos.left - dx;
    },
    mouseUpHandler: (e)=>{
      console.log('mup ');
      document.removeEventListener('mousemove', handler.mouseMoveHandler);
      document.removeEventListener('mouseup', handler.mouseUpHandler);

      handler.ele.style.cursor = 'grab';
      handler.ele.style.removeProperty('user-select');
    },
  };
  
  el.addEventListener('mousedown', handler.mouseDownHandler);
  
  return;
};




let module = {
  getExistingFile,
  saveToDbjson,
  showdiv,
  dragOverHandler,
  dropHandler,
  menuClick,
  updateHidden,
  updateAll,
  updateViewType,
  updatePosn,
  updateCm,
  keydown,
  toggleMenuOff,
  clickout,
  refresh,
  highlightSurname,
  highlightAll,
  showhidden,
  setAncestryId,
  wrapFn,
};

window.chrombrowser = module;

await pageLoad();


</script>
	</body>
</html>
